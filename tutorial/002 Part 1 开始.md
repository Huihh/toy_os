# 第一章 文档



## 1.1 问题域（Problem domains）



工程师不仅在软件上下功夫，还要在他试图解决的「问题域」上努力。（这一段书上的内容相当抽象，我打算用自己的语言描述「问题域」）



> 问题域（Problem domains）就是要解决的所有问题以及解决这些问题所需要的知识。



光写代码不是很复杂，但是写出能够很好解决问题的代码很难。程序员不光要知道怎么写代码，还得理解要解决的问题。这可能需要非常专业的知识。



知道程序员的头发是怎么掉的了吧？

![](https://upload-images.jianshu.io/upload_images/15548795-ea2a4c90437fbae0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



程序员必须选择正确的编程技术，应用到试图解决的问题上面。因为技术的应用场景不一样，不能生搬硬套。



比如说：



很多应用不需要高性能的代码，但是急着上市。这个时候，解释型（比如 python）语言更好。它能满足这个需求。然而，比如像大型 3D 游戏或操作系统，编译型语言就更有优势，因为它最高效。



通常，对程序员来说，理解这么多东西真的太难了（需要相关专业的本科甚至更高的学位）。对这个领域的专家来说，学习编程，并把这些难的问题拆分小问题给程序员做，并不是很难。所以，也有领域上的专家自己写软件。



![](https://upload-images.jianshu.io/upload_images/15548795-05136dd0dfee2868.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





这本书就有一个这样的例子：*Operating System*



为了实现一个操作系统，需要一些电子工程的知识。如果一个 CS 的学生没有上过这个课，那么这个学生就没有机会实现一个操作系统。就算他们能实现一个操作系统，也要花大量的时间自学，或者在预写好的框架中填代码。因此，电子工程的学生更容易实现一个 OS。事实上，电子工程的学生只要学 C 和 数据结构与算法 就能实现一个设备驱动。这样离操作系统也就不远了。



![](https://upload-images.jianshu.io/upload_images/15548795-7b2fc923de6441d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



写一个操作系统所需的知识与其他领域的知识重合（如上图所示）。为了有效地实现一个操作系统，极其需要其他的知识。那么，掌握到什么程度才够呢？一个软件工程师至少需要能够**读懂硬件产商准备的使用他们硬件的文档**



学习编程语言，甚至是 C 语言或汇编语言，不意味着一个软件工程师能够自动掌握硬件编程甚至相关领域低级语言编程。一个人花十年时间写 C/C++ 他都不一定能够写出一个操作系统。因为他缺少相关知识。就像只学习英语还是不能读懂用英语写的数学书一样。



了解一两种语言显然是不够的。如果一个程序员靠搬砖为生，他最好精通除了软件外的一至两个领域，否则他的工作很可能被只在业余时间学习的领域专家拐跑了。



![](https://upload-images.jianshu.io/upload_images/15548795-f9db3f7d3be74349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





## 1.2 解决问题的文档



为了学习一个相关领域，文档非常非常重要。很显然，为了一代一代的传递知识，文字信息已经被用了上千年了。



![](https://upload-images.jianshu.io/upload_images/15548795-1e136aa00bc6d3b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



文档是所有重要事情的集合，没有文档：



+ 新人加入项目时会超级艰难
+ 管理项目也会变得很难，因为人们会忘记那些还没解决的 Bug
+ 客户也很难理解如何去使用这个产品。然而，文档不应该以书的形式存在。他可以写在 HTML 里面也可以写在用户的图形界面里。重要的信息必须被保存在安全的地方，也必须十分容易就能拿到



有很多种文档。然而，为了加强对相关领域的理解，应该要写两种文档——**软件需求文档（software requirement document）**和**软件规范（software specification）**



### 啥是软件需求文档（software requirement document）



>  软件需求文档包括一系列的需求以及对要解决问题的描述。



一个牛逼的软件解决了一个商业上的问题。但是，什么问题被解决？客户又提了什么要求？这杂七杂八的列出来的需求都是我们程序员需要填的坑。苦逼 :(



![](https://upload-images.jianshu.io/upload_images/15548795-e6392d2c85933e65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



但是在交付软件的时候，那些被列出来的需求很少是有用的。在上一节我们提到**最蛋疼的不是编程，而是我们必须很好的解决问题**。大多数软件的设计与实现依赖待解决问题的领域知识。越能理解相关知识，越能写出牛逼的软件。



举个栗子



咱人类已经造了几千年的房子了，对造房子的理解已经很深了。所以我们能够很容易地造出很好的房子。写软件不是这样。你写的代码很难被读懂通常是因为别人不懂你这块领域的知识。



在这本书中，我们将不断在各种硬件设备的底层摸索。



因为，软件质量取决于对问题领域的理解，所以**软件需求文档（software requirement document） ** 应该包含对问题领域的描述



但是注意！对软件的需求不是：



+  *What or How*

  What 和 How 都是模糊的概念。任何东西都能是 *what* 也能是 *how* 

+ 概述（Sketches）

  软件需求文档相关问题领域的解释。不应该概述软件是如何实现的。一些问题甚至能够直接从对该问题的描述中被解决。成为最后成果的一部分。比如：

  + 用户能够在**下拉带单**中选择书籍
  + 书籍被存放在**链表**当中
  + 等等



在未来，书籍不是被列在下拉菜单中，而是直接列在页面上的缩略图中。书籍应该重新存储在图中，而且图的每个节点不光能代表书籍，还能用来查找相关书籍，这样推荐系统就能在下个版本中出现。



需求文档再更新的时候，应该删除所有过时的实现细节，因此需要额外的努力来维护需求文档。当开发和维护文档需要同样努力的时候，开发人员就会放弃文档，到了那个时候，所有人都会咆哮：文档真**的垃圾！



![](https://upload-images.jianshu.io/upload_images/15548795-86a6e459ff9d1d27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





**通常情况下，不能够点对点实现需求**。



举个栗子 ⚆_⚆ 



一个正常的用户希望在操作系统上跑有图形界面的程序或者游戏。但是对于这样一个需求，我们不能直接做到，因为操作系统被划分了很多层，每一层对他的上面一层隐藏了很多细节。为了能够实现一个 OS。需要学习很多领域的大量知识，尤其是如何让操作系统跑在一个不是个人计算机的设备上。



最好在需求文档中包含与问题域相关的信息。测试需求文档质量的一种好方法是**将其提供给领域专家进行校对，以确保他能够彻底理解材料。需求文档也可用作帮助文档，或者用于编写更简单的文档**



### 啥是软件规范（Software Specification）



简单说，软件规范就是接口设计，同样也受该问题领域的限制。就比如书，有个软件只能接受英语不能接受其他语言。对于一个硬件设备来说，规范是非常重要的，因为软件依赖硬件。事实上，大多数情况下硬件的规范短小精悍。这样做是因为一个硬件打从娘胎里出来，就不可能再回去。如果错误发生了，硬件产商会名利尽损。



注意！与需求文档类似，规范文档只关注接口设计，如果实现的细节堆进去了，与迭代的版本同步就变成了负担，长久以往，程序员又该骂娘了。



另一个重要的标志是，尽管规范文档灰常重要，但是在开发之前不是必须的。他可以有这样一个顺序：在完全完成开发之前或者之后；又或者在某些部分已经完成的时候，边开发边写文档；保证接口安全好用的时候再写入规范文档中。不管怎么样，在最后的时候接口文档一定要有。

o(￣ヘ￣o＃)





### 用于编写 x86 操作系统的文档



（开心吗？终于要开始了）

![](https://upload-images.jianshu.io/upload_images/15548795-dec1f56ee97e7bd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

当问题领域和编程的问题领域不同的时候，需求文档和规范文档通常是分开的。然而，当一个问题的领域是编程问题领域的子集的时候，规范文档几乎能包含了所有，所以两者的内容是可以交叉的。



上一节我们说，文档非常重要，为了实现一个操作系统，我们需要足够的文档去获取足够的知识。



我帮你收集好了：



 Intel® 64 and IA-32 Architectures Software Developer’s Manual (Volume 1, 2, 3)

 Intel® 3 Series Express Chipset Family Datasheet

 System V Application Binary Interface



除了 Intel 官方的网站，这本书的网站也会包含一些文档。



为了彰显我 Intel 的牛逼，Intel 的文档不光很清楚地写了这两种文档，还给这两种文档重新命名了。

+ 与需求文档对应的章节叫`Functional  Description` ，这一章中包含了对问题领域的详细描述。
+ 而与规范文档对应的章节叫做`Register Description`，这一章中包含了所有编程接口。

这两种文档都没有实现细节。Intel 的文档真的是业界良心，是我们广大程序员写需求文档和规范文档的楷模。



当然了，这么牛逼的文档也含有其他章节，我会在本书的其他章节中介绍。



੭ ᐕ)੭*⁾⁾ 第一章结束，完结撒花。

















