# 第五章 剖析程序

程序都是由代码和数据组成，并只由这两部分组成。可是，如果一个程序完全由它自己的代码和数据组成，站在操作系统（以及人）的角度来看，它不知道在程序中，哪个二进制块是程序和哪个块是原始数据，从程序哪里开始执行，哪个内存区域需要保护和哪个区域可以自由修改。因此，每个程序应该包含额外的元数据，用于在与操作系统通信时，告知操作系统如何处理它。



编译一个源文件，所产生的机器代码存储在目标文件中，目标文件是个二进制块。一个或多个目标文件组合在一起产生一个可执行二进制文件。可执行二进制文件是一个完整的程序，可在操作系统中运行。



**readelf** 是一个程序，它能识别和显示一个二进制文件中的 **ELF** 元数据, 这个二进制文件可以是一个目标文件或一个可执行文件。可执行可连接格式简称 **ELF**，**ELF** 是可执行文件最开始部分的内容，用于给操作系统提供 必要的信息，使其能被加载到主内存并运行。**ELF** 类似于书的目录。在书中，目录列出了主要章节和子章节的页码，为了方便查找，甚至还有数字和表格。同样的，**ELF** 列出了代码和数据的各个部分，还有每个符号的内存地址和其他信息。



一个 **ELF** 由以下几部分组成：

- **ELF header**：可执行文件的第一节，用于描述文件的组成。

- **program header table**：固定大小结构的数组，用于描述可执行文件的段。

- **section header table**：固定大小结构的数组，用于描述可执行文件的节。

- **Segments ans sections**：是 **ELF** 二进制中的主要内容，代码和数据被切分成不同目的的块。

  段由零个或多个节组成，在操作系统运行时直接被加载。

  节是一个二进制块，它是：

  - 在程序运行时，在内存中有效的真正的程序代码和数据。
  - 其它节的元数据，仅用于链接过程中，在最终可执行文件中不存在。

链接器使用以下节构建段。

![](E:\Work\OS\toy_os\pictures\Part 5\Snipaste_2019-05-13_10-33-19.png)



后面我们将使用 **GCC** 将我们的内核编译成一个 **ELF** 可执行文件，显示的指示如何创建段，并使用链接脚本（文本文件，指示链接器如何产生二进制）将其加载到内存中。现在，我们将开始剖析 **ELF** 可执行文件的详细结构。



## 5.1 参考文献

















































































