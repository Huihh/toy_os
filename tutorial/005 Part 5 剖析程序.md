# 第五章 剖析程序

程序都是由代码和数据组成，并只由这两部分组成。可是，如果一个程序完全由它自己的代码和数据组成，站在操作系统（以及人）的角度来看，它不知道在程序中，哪个二进制块是程序和哪个块是原始数据，从程序哪里开始执行，哪个内存区域需要保护和哪个区域可以自由修改。因此，每个程序应该包含额外的元数据，用于在与操作系统通信时，告知操作系统如何处理它。



编译一个源文件，所产生的机器代码存储在目标文件中，目标文件是个二进制块。一个或多个目标文件组合在一起产生一个可执行二进制文件。可执行二进制文件是一个完整的程序，可在操作系统中运行。



**readelf** 是一个程序，它能识别和显示一个二进制文件中的 **ELF** 元数据, 这个二进制文件可以是一个目标文件或一个可执行文件。可执行可连接格式简称 **ELF**，**ELF** 是可执行文件最开始部分的内容，用于给操作系统提供 必要的信息，使其能被加载到主内存并运行。**ELF** 类似于书的目录。在书中，目录列出了主要章节和子章节的页码，为了方便查找，甚至还有数字和表格。同样的，**ELF** 列出了代码和数据的各个部分，还有每个符号的内存地址和其他信息。



一个 **ELF** 由以下几部分组成：

- **ELF header**：可执行文件的第一节，用于描述文件的组成。

- **program header table**：固定大小结构的数组，用于描述可执行文件的段。

- **section header table**：固定大小结构的数组，用于描述可执行文件的节。

- **Segments ans sections**：是 **ELF** 二进制中的主要内容，代码和数据被切分成不同目的的块。

  段由零个或多个节组成，在操作系统运行时直接被加载。

  节是一个二进制块，它是：

  - 在程序运行时，在内存中有效的真正的程序代码和数据。
  - 其它节的元数据，仅用于链接过程中，在最终可执行文件中不存在。

链接器使用以下节构建段。

![](E:\Work\OS\toy_os\pictures\Part 5\Snipaste_2019-05-13_10-33-19.png)



后面我们将使用 **GCC** 将我们的内核编译成一个 **ELF** 可执行文件，显示的指示如何创建段，并使用链接脚本（文本文件，指示链接器如何产生二进制）将其加载到内存中。现在，我们将开始剖析 **ELF** 可执行文件的详细结构。



## 5.1 参考文献

**ELF** 的规范在 **Linux** 中可以在 **man** 页面中查找。

$ man elf

它是理解和实现 **ELF** 的一个很有帮助的资源。然而，在你读完本章之后，它将更容易使用，因为在规范中包含其实现细节。



默认的规范是通用的，每个 **ELF** 都遵从。然而，每个平台都提供其特有的额外功能。对于 **x86** 架构的 **ELF** 规范，目前在 GitHub 上由 H.J.Lu 维护，地址：[https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI ]()。



平台依赖的细节参考通用 **ELF** 规范中的 **processor specific** 部分。我们不探究这些细节。只关注通用规范。就已足够为我们的操作系统制作一个 **ELF** 二进制镜像了。



## 5.2 ELF header

可以使用 **readelf** 查看 **ELF** 的头信息。

$ readelf -h hello

输出如下：

![](E:\Work\OS\toy_os\pictures\Part 5\Snipaste_2019-05-13_11-09-51.png)

我们接着来看每个字段含义：

**Magic**：显示唯一的处理文件的原始字节是**ELF** 可执行二进制文件。每个字节给出一个简短的信息。

在示例中，**magic** 字段值如下：

Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00

| 字节                    | 含义                                                         |
| ----------------------- | ------------------------------------------------------------ |
| 7f 45 4c 46             | 预定义值。第一个字节固定为 **7F**，剩余 3 个字节代表字符串 “**ELF**”。 |
| 02                      | 详见后面 **Class**  字段。                                   |
| 01                      | 详见后面 **Data** 字段。                                     |
| 01                      | 详见后面 **Version** 字段。                                  |
| 00                      | 详见后面 **OS/ABI** 字段。                                   |
| 00 00 00 00 00 00 00 00 | 填充字节。这些字节没有用到，通常用 0 填充。填充字节用于对齐。保留用于将来使用。 |



**Class**：**Magic** 中的一个字节。用于指定文件的类型或容量。

| 值   | 含义            |
| ---- | --------------- |
| 0    | 无效的类型      |
| 1    | 32-bit 目标文件 |
| 2    | 64-bit 目标文件 |



**Data**：**Magic** 中的一个字节。用于指定目标文件中处理器指定的数据编码格式。

| 值   | 含义                                  |
| ---- | ------------------------------------- |
| 0    | 无效的数据编码                        |
| 1    | 小端（Little endian），2’s complement |
| 2    | 大端（Big endian），2’s complement    |



**Version**：**Magic** 中的一个字节。用于指定 **ELF header** 版本号。

| 值   | 含义     |
| ---- | -------- |
| 0    | 无效版本 |
| 1    | 当前版本 |



**OS/ABI**：**Magic** 中的一个字节。用于指定目标操作系统 **ABI**。最初时，它是一个填充字节。

| 值   | 含义                                                        |
| ---- | ----------------------------------------------------------- |
| xx   | 参考最新版 **ABI** 文档，该文档是一长串不同操作系统的列表。 |



**Type**：用于标识目标文件的类型。

| 值     | 含义               |
| ------ | ------------------ |
| 0      | 没有对应的文件类型 |
| 1      | 可重定位文件       |
| 2      | 可执行文件         |
| 3      | 共享目标文件       |
| 4      | 核心文件           |
| 0xff00 | 特定处理器，下限   |
| 0xffff | 特定处理器，上限   |

0xff00 ~ 0xffff 值是被保留用于处理器定义额外有意义的文件类型。





















































