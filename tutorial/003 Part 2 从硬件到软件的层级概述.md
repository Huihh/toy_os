# 第二章 从硬件到软件的层级概述



这一章将告诉你软件和硬件是如何交互的，以及如何在物理层面上表示软件。



## 2.1 一个 bit 的物理级实现



所有的电子设备，无论简单还是复杂，都是操作电流去达到预期的效果的。计算机当然不例外。我们写软件的时候，实际上，我们间接操纵了电流。只有这样，底层的机器才能发挥作用。



为了理解这个过程，我们假想一个简单的电灯泡。一个电灯泡可以有两种状态开或者关，关意味着 0 开意味着 1。



![](https://upload-images.jianshu.io/upload_images/15548795-c75443a3636baf56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



然而，这样有个问题，**开关是人操纵的**。我们需要的是一个根据电压的自动开关。为了能够自动改变电子信号，有三个牛 b 的人（William Shockley, John Bardeen and Walter Brattain）发明了一种叫做「*晶体管（transistor）*」 的设备。**这个设备开启了整个计算机行业**。



实际上，晶体管就是电阻。电阻的值可以根据输入电压的值变化而变化。



有这样一个特性，晶体管就可以变成一个电流放大器（高电压，低阻值），根据电压的大小，也可以是一个电信号的开关（阻隔或非阻隔）。

0 v 的时候没有电流可以通过，因此它就像一个开关打开的电路（灯泡关闭）因为电阻的值足够阻隔电流。同样的是，在 3.5 V 电流可以通过晶体管，因为电阻值下降了，有效地实现电子流动，因此就像一个开关闭合的电路。





一个 bit 有两种状态：0 或者 1。与电灯泡相同，可以被关闭和打开。bit 来自电流：bit 0 用 0v（无电流）表示，bit 1用 3.5V 到 5V（有电流）表示。晶体管可以正确地实现 bit，因为它可以根据电压调节电流。



### 2.1.1 MOSFET 晶体管



被发明创造出来的晶体管打开了一个全新的微型数字设备的世界。在这之前，真空管（仅仅比灯泡好点）被用来表示 0 和 1，需要人们手动打开或者关闭。



1959 年，Dawon Kahng 和 Martin M. (John) Atalla 在贝尔实验室中发明了 MOSFET 晶体管（M etal–Oxide–Semiconductor Field-Effect MOSFET T ransistor）。这种晶体管更好更适合。



### 2.2 超越晶体管：数字逻辑门



所有数字设备都设计有逻辑门。*逻辑门（logic gate）* 是能够实现 bool 类型函数的设备。每一个逻辑门都包含输入和输出。所有的计算机都是由非常多个逻辑门组合起来的，也就是由非常多的 bool 型函数构成。

![](https://upload-images.jianshu.io/upload_images/15548795-0914b1be96585bb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 2.2.1 逻辑门背后的原理

*逻辑门（Logic gates）*仅接受二进制和输出二进制。换句话说，逻辑门就是转换二进制值的函数。幸好存在着处理二进制数的数学理论——「布尔代数（Boolean Algebra）」



当逻辑门能够实现一些特定的布尔函数的时候，所有的布尔函数集合在功能上是完整的，只要这些特定的布尔函数能够构造其他的布尔函数。



不久，有人（Charles Sanders Peirce）就证明了 NOR 或者 NAND 就能组合其他所有的布尔函数。布尔函数的可以用逻辑门表示，也就是说，NAND 或者 NOR 的逻辑门就可以表示其他所有的逻辑门。



最简单的逻辑门 CMOS 电路可以实现一个逆变器（NOT gates）。几个逆变器在一起就能构成一个 NAND 门。有了 NAND 门我们就能创建所有的逻辑门了。这就是为什么晶体管的发明，以及 CMOS 电路彻底改变了计算机行业。



我们应该要意识到，布尔函数有多么的牛逼。



![](https://upload-images.jianshu.io/upload_images/15548795-6f4ded1a20349a64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 逻辑门的实现：CMOS 电路



底层中每一个逻辑们都是一个叫做的 CMOS（Complementary CMOS MOSFET）电路。CMOS 包含两个晶体管。NMOS 和 PMOS。最简单的 CMOS 电路就是一个逆转器或者 NOT 门：



![](https://upload-images.jianshu.io/upload_images/15548795-ba206b6a07617803.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



NOT 门完成了，NAND 门也就不远了：



![](https://upload-images.jianshu.io/upload_images/15548795-4de3f5e85a50347b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





有了 NAND 门，其他门也就有了。就如图示的那样如此简单的电路就能实现一个逻辑操作。真的是太神奇了。在我们的编程语言中，NOT 操作 就是 ~。& 就是 AND 门。代码并不是跑在神秘的魔法盒上。相反，代码的执行是非常清晰与透明的，就是在小小的硬件电路上运行。



当我们写软件的时候，我们简单地操纵物理水平的电流来运行适当的电路以产生期望的结果。然而，整个过程在某种程度上与任何涉及电流的思想无关。这是真正的黑魔法，很快就会解释.



CMOS 的一个有趣特性是 **k 个输入门使用 k 个 PMOS 和 k 个 NMOS 晶体管（Wakerly，1999）**。所有逻辑门都是由 NMOS 和 PMOS 晶体管构成的，门是所有数字设备的构建模块，从简单到复杂，包括任何计算机。这种模式使得**实际物理实现和逻辑实现**得以分开。



数字设计是通过逻辑门设计完成的，然后被“编译”成物理电路。实际上，稍后我们将看到逻辑门成为描述电路如何工作的语言。了解 CMOS 的工作原理对于了解计算机的设计方式以及计算机的工作方式非常重要。



最后，带有导线和晶体管的被封装好实际电路叫做**芯片（chip）**。芯片是刻蚀集成电路的基板。但是在消费者市场上，**芯片**也指完全封装的集成电路（就是我们平时理解的芯片）。上下文不同，芯片的意义也不同。



--------------------------

举个栗子：(ﾟд⊙)



74HC00 是一个有两输入的 NAND 门的芯片。芯片配有 8 个输入引脚和 4 个输出引脚，1 个引脚用于连接电压源，1 个引脚用于连接到地。该器件是 NAND 门的物理实现，我们可以实际使用它。但是芯片不是只有一个门，而是带有 4 个可以组合的门。每种组合都可以实现不同的逻辑功能，有效地创建其他逻辑门。这个功能使得芯片十分流行。



如前所述，上面的每个门只是一个带有电子流的简单 NAND 电路。然而，许多这些 NAND 门芯片组合在一起可以构建一个简单的计算机。物理层面的软件只是电子流。



![](https://upload-images.jianshu.io/upload_images/15548795-f7c5f41cb535dc8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



![](https://upload-images.jianshu.io/upload_images/15548795-4e437eb97fabfbfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



![](https://upload-images.jianshu.io/upload_images/15548795-ee3971ac89567de8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



如何使用 74HC00 创建上述门？真的很简单：每个门有 2 个输入引脚和 1 个引脚输出，我们可以将 1 个 NAND 门的输出写入另一个 NAND 门的输入，从而将 NAND 门连接在一起，产生如上图的门。



--------------------------





### 2.3 超越逻辑门：机器语言



因为门只接受一系列的 0 和 1，所以建立在门上的硬件设备只能理解 0 和 1。而且，设备只能以系统的方式接受 0 和 1。*「机器语言」（Machine language）* 是独一无二的 bit 代码。我们的设备可以识别他们并做出反应。在计算机系统中，有属于自己的机器语言的设备叫做 **CPU**。控制所有计算机内部的所有活动。



举个栗子：Σ(*ﾟдﾟﾉ)ﾉ



在 x86 架构中，10100000 告诉 CPU 相加两个数字，又或者 000000101 去停止计算机。在计算机时代的上古时期，程序员只能用二进制编程。



![](https://upload-images.jianshu.io/upload_images/15548795-ba59c11748d564f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



为什么这样的 bit 模式会有用？原因是每条指令都是一个实现指令的小电路。这种 bit 模式与在计算中程序通过名字调用程序的模式类似。一种 bit 模式就是 CPU 一个小功能的名字。如果 CPU 找得到，就执行。



注意：CPU 不是唯一一个有自己机器语言的设备。CPU 只是一个代号用来指示他是一个能控制计算机系统的硬件设备。一个有自己机器语言的设备就是*可编程设备（programmable device）* 。因为用户可以使用该语言命令设备执行不同的操作。例如，打印机具有一组命令，用于指示它如何填充页面。



-------------------------------------



再举个栗子：(☉д⊙)



用户可以在不知道其内部信息的情况下使用 74HC00 芯片，但只能使用该设备的接口。首先，我们需要知道它的布局：



![](https://upload-images.jianshu.io/upload_images/15548795-d1e147eedd3b0e1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



每个引脚的作用：



![](https://upload-images.jianshu.io/upload_images/15548795-1388206ddbce007d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

最后怎么使用这些引脚



![](https://upload-images.jianshu.io/upload_images/15548795-eadc1c292f2d01d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



注意：



+ n 是数字 1 2 3 4
+ H 是高电压；L 是低电压；X 是任意值



`上述表中`提供了包含所有可能的输入和输出的真值表，其中还描述了设备中所有引脚的使用。用户不需要知道实现，但是可以在这样的表上使用该设备。我们可以说上面的**真值表就是设备的机器语言**。由于该设备是数字设备，因此其语言是二进制字符串的集合



+ 该器件有 8 个输入引脚，这意味着它接受 8 位二进制字符串。
+ 该器件具有 4 个输出引脚，这意味着它可以从 8 位输入产生 4 位二进制串



输入的数字是设备可以理解的内容，输出的数字是设备说出来的内容。两者共同构成了设备的语言。即使这个设备很简单，但它可以接受的语言包含很多二进制字符串：$2^8 + 2^4 = 272$。然而这个数字还是太小了。像 CPU 那样的设备就有上百个引脚（pin）



回到之前的内容，74HC00 就是一个简单的有两个 4 位输入的 NAND 设备。



![](https://upload-images.jianshu.io/upload_images/15548795-101c34720a44fc87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





这张图也可以这样表示：



![](https://upload-images.jianshu.io/upload_images/15548795-8adee3eb2baf2475.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



上图中：绿色信号是输入;蓝色信号是输出





另一方面，如果实现 OR 门，我们只能从 74HC00 构建一个 2 输入 OR 门，因为它需要 3 个 NAND 门：2 个输入 NAND 门和 1 个输出 NAND 门。每个输入与非门仅表示或门的 1 位输入。在下图中，每个输入与非门的引脚始终设置为相同的值（两个输入均为 A 或两个输入均为 B），以表示最终门的单个位输入



如图所示：

![](https://upload-images.jianshu.io/upload_images/15548795-f5082d2a11385001.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

--------------------------------------------



为了实现 4 位的 OR 门。我们需要总共四个 74HC00 芯片配置为 OR 门，如图所示：



![](https://upload-images.jianshu.io/upload_images/15548795-dc46f86da9f24622.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)







### 2.3.2 汇编语言



汇编语言是二进制机器代码的符号表示。给出了位模式的助记符名称。这在当时是一个巨大的飞跃。举个例子，当你想停止计算机的时候，你再也不用去写 000000101 了，只用写一个简单的 hlt 就行了。



像这样的抽象使得指令更容易记，因此可以记住更多的指令，减少查找指令的时间，以及更快的编程。



甚至到今天，理解汇编对底层编程领域依然十分重要。程序员记住的汇编指令越多，对机器的架构理解越深。



举个栗子：(๑•̀ㅂ•́)و✧



我们现在可以创建一个有两条指令的设备：



```assembly
or   <op1>, <op2>
nand <op1>, <op2>
```



+ **or** 接受两个 4 位操作数。这相当于由 4 个 74HC00 芯片构建的 4 输入OR 门设备。

+ **nand** 接受两个 4 位操作数。这相当于一个单独的 74HC00 就如上面那样

在上一个例子中的门实现了指令。到目前为止，我们只指定输入和输出并手动将其提供给设备。也就是说，执行操作有两个步骤



+ 手动选择一个设备
+ 手动将电信号输入给引脚



首先，我们想自动化选择设备的流程。也就是说，我们想用简单的汇编指令然后选择出正确的设备执行指令。解决这个问题很简单：



+ 给每一个指令套一个二进制头，这个叫做**「操作码（operation code or opcode）」** 。这个二进制头嵌在输入里面。这个值被定义在下图中：



![](https://upload-images.jianshu.io/upload_images/15548795-c8119c248eac97cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



现在每一个输入包含操作码



举个栗子：φ(≧ω≦*)♪



```assembly
nand 1100, 1100
```



上面这个指令等价于`0011001100` 前两个 bit 00 是 nand 指令的编码，在上面的图中被列出。



（下面一段话比较绕口）

**根据二进制代码尤其是指令代码，添加特定的设备以选择一个设备，这个特定的设备叫做「解码器（decoder）」**



解码器是 CPU 的重要组成部分。它用来决定哪个使用哪个电路。在上面的例子中，当输入 **00**11001100 给一个解码器的时候，由于操作码是 00，所以会数据会被发送给 **NAND** 设备。



最后！写汇编代码是比写二进制更容易的方式。当我们在文本文件中编写汇编代码并保存时，一个名为 **assembler** 的程序会将文本转换为设备可以理解的二进制字符串。





那么第一个 **assembler** 又是怎么出现的呢？它是直接用二进制代码写的@

在下一个版本后，一切都变简单了。



![](https://upload-images.jianshu.io/upload_images/15548795-16bc06d5337dd7d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

程序员用汇编代码编写汇编程序，再使用 assembler 编译。然后将这些二进制字符串存储在另一个设备中，该设备稍后可以被检索并发送到解码器。 



**「存储设备（storage device）」**可以用来存储机器指令，实际上也就是一堆能保存 0 1 的电路。



解码器（decoder）就像其他数字设备一样由逻辑门构成。然而，一个存储设备（storage device） 可以是其他任何只要能存储 0 1 以及能够被检索的设备。不管用什么技术，只要能够存储数据以及可以被访问，那就可以做存储设备。



确实，现代的设备都太**的复杂了。理解每一个实现细节真的没有必要。我们只要知道如何使用接口就行了︿(￣︶￣)︿。



（这就是程序员的本质吧）

![](https://upload-images.jianshu.io/upload_images/15548795-c9e70dfaf07f8a39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



整体机器结构如下：



![](https://upload-images.jianshu.io/upload_images/15548795-800771c9a84988cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



一个计算机本质上就实现了这些操作：



+ 从存储设备中拿一个指令
+ 解码这个指令
+ 执行这个指令



或者，简单来说：fetch - decode - execute 的循环。上面图示的设备真的很简单，仅仅有 fetch - decode - execute 的循环。但是已经能够代表一个计算机了。



添加更多的设备和分配更多的操作码已经更新解码器就能实现更多的指令。Apollo Guidance Computer 一个数字计算机，在 1961 - 1972 被用来运行 Apollo 空间站的程序。这个计算机全部都是 NOR 门创建的其他逻辑门（当然还有其他的选择——NAND 门）。相同，如果我们不停提高抽象我们的设备，最终就能够变成一个全功能的电脑。



### 2.3.3 编程语言



汇编就是从 0  到 1 的巨大飞跃。随着时间的流逝，人们意识到很多的汇编代码块可以重复使用。如果可以不写那些重复的汇编代码块只需要使用更简单的文本去使用那些汇编代码就更好了！



举个栗子：ヾ(≧▽≦*)o



汇编代码块检查一个变量是否大于另一个变量，如果是，则执行代码块，否则执行另一个代码块;在 C 中，这样的汇编代码块由接近人类语言的 if 表示。



也就是这样：



![](https://upload-images.jianshu.io/upload_images/15548795-29fb499d787ff3b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



程序员写一些简单的文本块来代表常见的汇编代码块，比如在上面的 if 语法，然后写了一个程序转换这些文本块到汇编代码。这样的程序被叫做**编译器**（compiler）

（就像这样）

![](https://upload-images.jianshu.io/upload_images/15548795-370e32125a2bac6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





编程语言可以实现的任何软件逻辑，硬件也可实现这些软件逻辑。反过来也是正确的：在电路中实现的任何硬件逻辑都可以在编程语言中重新实现。**原因很简单，无论是编程语言，汇编语言，机器语言甚至是逻辑门都只是来表达计算的语言**。



软件无法实现硬件无法实现的功能，因为编程语言只是使用底层硬件的简单方法。程序设计语言被转换为对 CPU 有效的机器指令。否则，代码不可运行，因此是无用的软件。相反，软件可以做硬件能做到的任何事情，要知道代码只是使用硬件的简单方法。



越高级的语言，离硬件越远。在一些高级编程语言中，例如Python，程序员无法操纵底层硬件，尽管能够提供与低级程序设计语言相同的计算。原因是高级语言希望隐藏硬件细节，以免程序员处理与当前问题域无关的细节。



想要这么便捷，当然不是免费的。那需要软件有额外的代码来管理硬件细节（比如内存）。这样会使代码跑得更慢，使直接硬件编程更难甚至不可能。



这也是为什么，C 语言是写一个操作系统的首选语言。因为，C 只是底层硬件的薄包装，更容易理解硬件是如何工作的。



每一个编程语言都代表着一种编程语言的思想。高级编程语言帮助人们集中于问题域上面，而不是硬件。并且某些时候程序员比更机器重要。低级编程语言帮助程序员集中于机器的内部工作，因此很适合与操作硬件有关的问题。这就是存在这么多语言的原因。使用合适的工具进行工作，以获得最佳效果。





## 2.4 抽象

抽象是一种隐藏复杂性的技术。



举个例子：<(￣︶￣)>



写程序不需要其他领域的知识，除了最底层。要有电路知识。一个人不仅需要深入理解电路是如何工作的还有站在高层次（比如逻辑门）的地方思考。这是一个令人分心的过程，因为设计者必须不断得将这个想法转化为电路。它不仅效率更高，而且同样精确。因为设计师可以将所有精力集中在用高级思维来验证设计上。设计师可以简单地直接思考他的高级想法，然后将想法转化为电路。它不仅效率更高，而且同样精确，因为设计师可以将所有精力集中在用高级思维来验证设计上。当新设计师到来时，他可以轻松理解高级设计，从而可以继续开发或维护现有系统。



### 2.4.1 为什么抽象有用

在所有层中，抽象的作用如下：

+ 逻辑门抽象 CMOS 的所有细节
+ 机器语言抽象所有的逻辑门细节
+ 汇编语言抽象所有的机器语言细节
+ 编程语言抽象所有的汇编语言细节



我们可以看到：底层语言是如何构成高层语言的



+ 底层有一些重复的部分，这个重复的部分，被抽象出来并在它的上面建立了一个语言

+ 高层语言剥离了层特定（非重复）细节，集中处理重复细节
+ 这些重复的细节用更简单的语言描述，而不是用底层的语言



我们要意识到，每一层只是一个更方便的方法，去**描述**它的底层。只有在用较高层的语言完全创建**描述**之后，才能用较低层的语言实现描述。



+ CMOS 层有一个重复的模块确保逻辑电路们能够转换成 CMOS 电路，**一个 k 输入的们使用 k 个 PMOS 和 k 个 NMOS 晶体管**。因为数字设备只使用 CMOS，所以有这样一门语言出现了，它隐藏了 CMOS 电路。它就是**逻辑门**。



+ 逻辑门隐藏了电路的语言，集中于如何实现原始的布尔函数并把这些布尔结合构成新的函数。的逻辑门输入输出二进制数。由于有很多的重复模块，逻辑门被隐藏起来，创建了一个新的语言。**汇编**！汇编是一系列预定好的二进制模式并且能够使底层的硬件门发挥作用。

  

+ 不久，人们发现还是有很多重复的模块。于是出现了很多能把特定的文本转换成汇编代码的方法。因此，这些方法，逐渐演变成了如今的编程语言。 



**重复的模块就是抽象的关键，重复的模块就是抽象为什么会用的原因**。没有重复的模块，没有语言可以被创造，因此没有抽象





幸运的是！聪明的人类已经开发了一个研究模式的系统学科：**数学**。有个数学家这么说（ British mathematician G. H. Hardy (2005):）



> A mathematician, like a painter or a poet, is a maker of patterns. If his patterns are more permanent than theirs, it is because they are made with ideas（我就不翻译了）



难道一个数学公式不代表了一个模式吗？数学提供了一个正式的

系统来辨别和描述已存在的模式。因此，这个系统当然可以被应用在数字的世界中。数学可以使层次间的转换更容易，以及帮助我们理解所有层。



（就像这样）

![](https://upload-images.jianshu.io/upload_images/15548795-4d1be9b99437178f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 2.4.2 为什么抽象减少复杂度



抽象通过创建语言确实能够提高生产力，因为这样可以剥离于问题无关的细节。想象一下，用最底层的电路去写程序是多么的困难啊：直接用低级语言去实现高级语言的想法。如果这样，软件本身可能比问题域更难以理解与实现。也就是说，编程语言无法集中于问题的解决。换句话说，编程语言如果它的语法能够集中于解决问题则说明它具有良好的表达性。



在某种意义上，它能够做什么比它怎么实现的更有用。



----------------------------------------------



举个栗子：(つω｀)～



Graphviz （http://www.graphviz.org/）是一个可视化的软件提供的语言，叫做 dot，用来描述图表。



（像这样）

![](https://upload-images.jianshu.io/upload_images/15548795-7155b726a3f87859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



可以看出，代码完美地表达了图形是如何连接的。即使是非程序员也可以轻松理解和使用这种语言。 C 中的实现会更麻烦，并且假设绘制图形的函数已经可用。要绘制一条线，在 C 中我们可能会写如下：



```c
draw_line(a, b);
```



和这个比比 



a->b。



而且，a 和 b 必须在 c 中定义。与 dot 语言简单明了的语法比一比？然而，就算我们不考虑这些冗余，C 语言还有一个限制：它不能改变它的语言去适应问题域。一个问题域明确的语言可能更复杂，但是它能使问题域更加容易理解。如果一个问题域，必须用 C 表现出来，那么就会受 C 语言语法的限制。由于 C 不是一特定定义域的语言，而是一个通用目标的语言，那么问题域的知识就必须在细节中表现出来。





因此，C 语言程序员需要对问题的理解要更加深入，如果不能完全理解一个问题，那么软件也就不能开发出来了。



举个栗子：w(ﾟДﾟ)w



Linux 充满着被其他领域语言编写的程序，这些应用被放在 /etc 目录中。比如 web 服务器。而不是用与这个领域无关的语言，重新编写软件。

--------------------------------------------



通常，领域专家必须能够理解可以表达问题域的代码。甚至在软件领域，创建一个语言能够取代重复的模块也很有用。它帮助人们意识到在代码中存在这样的模式。这种模式使代码更容易维护，因为软件的结构可以被语言暴露出来。



只有能够变形使用问题域的语言才能实现这样的目标。这种语言叫做**可编程的编程语言**（a programmable programming）。不幸的是，这种能够使软件结构暴露出来的办法，不是受所有程序员的欢迎。因为必须使用新的语言和新的工具链来支持它。因此，软件结构和领域知识只能用通用的编程语言表达出来。也就是说，如果程序员不熟悉代码的模式与领域的知识，也就不能被理解代码。



一个最初的例子：（＃￣～￣＃）



读 C 控制硬件的代码，比如操作系统。哪怕他写了 20 年 C 代码，他也不读懂和写出来。







有了抽象，哪怕软件工程师不知道电路是如何设计的，也能理解设备的内部工作，这使得软件工程师能够写代码控制底层。



逻辑和物理上的分开实现也意味着，门电路的设计可以被重用哪怕底层的技术变化了。





举个栗子：→)╥﹏╥)



如果有一天生物电脑成为了现实



（这个吗？）

![](https://upload-images.jianshu.io/upload_images/15548795-899623d11209b268.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



整个门电路不是用 CMOS 实现了，而是一种细胞。在任何一种技术中：电子或生物学，只要逻辑门在物理上实现，就可以实现相同的计算机设计。





第二章结束。完结撒花 ( ͡° ͜ʖ ͡°)




```c
//
//                       _oo0oo_
//                      o8888888o
//                      88" . "88
//                      (| -_- |)
//                      0\  =  /0
//                    ___/`---'\___
//                  .' \\|     |// '.
//                 / \\|||  :  |||// \
//                / _||||| -:- |||||- \
//               |   | \\\  -  /// |   |
//               | \_|  ''\---/''  |_/ |
//               \  .-\__  '-'  ___/-. /
//             ___'. .'  /--.--\  `. .'___
//          ."" '<  `.___\_<|>_/___.' >' "".
//         | | :  `- \`.;`\ _ /`;.`/ - ` : | |
//         \  \ `_.   \_ __\ /__ _/   .-` /  /
//     =====`-.____`.___ \_____/___.-`___.-'=====
//                       `=---='
//
//
//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//               佛祖保佑         不要翻译错
//
//
//
```





