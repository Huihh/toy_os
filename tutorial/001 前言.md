# 操作系统从 0 到 1



## 前言



哈喽！



你可能不止一次地问过自己如何从头开始编写一个操作系统，甚至你可能已经有了数年的编程经验，对操作系统的理解却依然只限于一组抽象概念，而不知其具体实现。对于那些从未编写过操作系统的人来说，操作系统无异于黑魔法：操作系统可以通过编程语言中的 API 来理解程序员的请求，进而对硬件进行控制，堪称是一件奇物。学习编写操作系统听起来十分吓人，感觉就好像无论学了多少知识都不够一样。因此你现在阅读本书可能是为了对操作系统有一个更好的理解，想要成为一个牛逼的软件工程师。



**如果你就是我上面说的那类朋友，那么本书就是为你打造的**。学完本书，你将学到一些你所不知道但却很重要的知识，正是这些知识让你能够从零开始实现你自己的操作系统。是的，你没听错，真正的**从零开始**！没有任何现成的操作系统层哦~证明你能不能胜任操作系统开发者身份的时候到了！



你可能会问：“学习 Linux 的系统内部机制不是更实际吗？”



是……  

但也不是



学习 Linux 有助于你的日常工作流，但是如果你仅仅是使用现有的操作系统，就永远也不可能写出一个真正的操作系统。通过编写一个你自己的操作系统，你所获得的是你单纯学习 Linux 时学不到的知识。



以下列出了你学习编写操作系统部分的好处：



+ 你将了解到计算机在硬件层面上是怎样运作的，还将学会编写可以直接对硬件进行操作的软件
+ 你将学到操作系统的基础知识，这些知识可以使你轻松驾驭任何操作系统，而不仅仅是 Linux
+ 要想如愿入侵 Linux 系统，你至少需要自己编写一个操作系统。这就好比编写应用软件一样：想要搞波大的，就得先造个简单的
+ 你将接触到各种底层开发领域：逆向工程，漏洞利用，构建虚拟机，游戏控制台模拟器，等等。汇编语言将成为你进行底层分析最必不可少的工具（**请注意**，这并不意味着你一定用汇编来写操作系统）
+ 最后一点最重要：写操作系统很好玩！



### 为啥不看别的妖艳贱货咧？



现在已经有很多关于这个主题的书籍和课程了，并且这些教程都由知名教授和专家制作，我又何德何能写一本主题如此艰深的书？我要说的是，虽说确实存在许多优质资源，但很遗憾，他们都有点儿缺斤少两。

有哪一本书告诉你如何不依赖现成的操作系统来编译 C 代码和 C 运行时库吗？大多数关于操作系统设计和实现的书籍都只讨论了软件方面的内容，却忽略了操作系统与硬件的交互过程。重要的硬件细节被略过，而自学者却很难在网上找到这方面的资源。

本书的目的就是要弥补这方面的缺陷。你不仅仅会学到如何直接在硬件上编程，还会学到如何通过阅读硬件厂商的官方文件来编程。你不再需要求爷爷告奶奶地四处寻找资源来帮助自己理解硬件手册和文档：你自己就可以做到了。

最后，我是以自学者的角度来写这本书的。我会尽量写得详尽一点，这样你就可以节省下推测、搜寻信息的时间，把更多时间用在学习上。



这本书的焦点之一是教你通过阅读官方的文档实现自己的软件。这些来自像 Intel 的硬件产商的官方文档对直接跑在硬件上的操作系统或者软件是极其重要的。至少，一个操作系统开发者需要能够理解这些文档，在一系列硬件要求上完成软件。因此，第一章就是讨论相关文档以及其重要性。



另一个非常重要的特点是："Hello World" 中心。大多数例子围绕着 "Hello World" 编程。这让你了解这些核心概念。这些核心概念必须被学会。任何超过简单的 "Hello World" 的例子都会阻碍教授这些概念，因为这样会加长开始写一个操作系统的时间。



让我们和这本书一起潜下去。我希望我能提供足够的基础知识，帮助你理解这些资源。这本书尤其适合那些刚结束 C/C++ 课程的学生。想象一下，给以后的老板展示一下，哥哥我原来写过操作系统，是多么的牛逼啊。





### 小小的门槛



电路的基础知识：

+ 电学的基础概念：原子，电子，种子，质子，电流
+ 欧姆定律



如果你不熟悉也没关系，我告诉你一个秘籍：

https://www.allaboutcircuits.com/textbook/ 学习前两章就行了



C 语言基础尤其是：



+ 变量和函数声明/定义

+ while和for循环 

+ 指针和函数指针 

+ C中的基本算法和数据结构

  

Linux 基础：



+ 知道如何使用命令行打开目录
+ 知道如何使用选项调用命令 
+ 知道如何将输出管道传输到另一个程序



打字。我知道打字速度与解决问题无关，但至少你的打字速度应该足够快，不要让它降低学习体验。



读完这本书，你至少会学习到：



+ 如何通过阅读硬件数据表（hardware datasheets）从 0 写一个操作系统。在现实世界中，它就是这样的。你不能从 Google 中得到快速回答。
+ 从硬件到软件，全面了解计算机的层与层之间是如何关联的
+ 独立编写代码。复制粘贴代码毫无意义。当你自己解决问题的时候，才是你学到东西的时候。一些书上的例子会启发你，但是最大的问题还应该是你去克服。不要害怕，问题的答案还是会给你的，但这仅仅被用来在尝试后的自我检验
+ 熟悉 Linux 的开发环境以及熟悉使用常见的工具调试低级语言编程
+ 深入理解 x86 汇编
+ 一个程序到底是如何构造的以至于操作系统可以运行它
+ 如何使用 gdb 和 QEMU 调试一个直接跑在硬件上的程序。
+ 用纯 C 链接和加载裸机 x86_64。没有标准库。没有运行时开销。



## 这本书没讲啥



（也有我暂时装不了的逼）



+ 电子工程

  本书讨论了电子设备和电子工程的一些概念，这仅仅是为了介绍软件是如何跑在裸机上面的

+ 如何使用 Linux 或任何操作系统类型的书籍

  虽然 Linux 被用作开发环境和媒介来演示高级操作系统概念，但它并不是本书的重点。

+ Linux 内核开发

  这个主题上已经有很多高质量的书

+ 专注于算法的操作系统书籍

  本书更侧重于实际的硬件平台 - 英特尔 x86_64 - 以及如何编写一个利用硬件平台支持的操作系统。



### 这本书讲了啥



**第 1 部分为学习操作系统提供了基础。**



+ 第 1 章简要介绍了文档的重要性。文档对于学习体验至关重要，因此它们值得成为一个章节

  

+ 第 2 章解释了从硬件到软件的抽象层。我们的想法是深入了解代码的物理运行方式。

+ 第 3 章提供了计算机的一般体系结构，然后介绍了用于编写操作系统的示例计算机模型

+ 第 4 章通过使用英特尔手册以及常用指令介绍了 x86 汇编语言。本章详细介绍了高级语法如何与低级汇编程序相对应，使你能够轻松地阅读生成的汇编代码。在调试操作系统时，阅读汇编代码非常重要。

+ 第 5 章详细剖析了 ELF。只有通过了解二进制级别的程序结构，你才能在裸机上构建一个程序

+ 第 6 章介绍了 gdb debugger 以及常用命令的大量示例。你们熟悉了 gdb 以后，你就可以深入了解 debugger 的工作原理。这些知识对于在裸机上构建可调试程序至关重要



**第 2 部分介绍如何编写引导程序来引导内核。因此，被叫做 "Groundwork"。掌握了这一部分后，你们可以继续阅读下一部分，这是编写操作系统的指南。但是，如果你们不喜欢该演示文稿，可以查看其他地方，例如 [OSDev Wiki](http://wiki.osdev.org/)**



+ 第 7 章介绍了引导程序是什么，以及如何用汇编写一个，以及如何在 QEMU（一个硬件模拟器）上加载它。此过程涉及键入重复和长命令，因此可以用 GNU Make。通过自动化重复的部分和简化与项目的交互提高生产力。本章还说明了 GNU Make 在上下文中的用法
+ 第 8 章通过解释组合目标文件时的重定位过程来介绍链接。除了引导程序和用 c 语言编写的操作系统之外，这是在裸机上构建可调试程序所需的最后一块拼图。



**第 3 部分提供了有关如何编写操作系统的指南，此时你应该自己实现操作系统并为你的创建感到自豪。这份指南包括为了实现操作系统从硬件到软件必要概念的简单解释。没有这份指南，你将花费大量的时间收集信息。然后提供从概念到代码的蓝图**





