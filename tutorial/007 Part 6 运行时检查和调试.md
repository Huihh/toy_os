# 第六章 运行时检查和调试

调试器是一个程序，它可以检查正在运行的程序。调试器可以启动和运行一个程序，并可以暂停在指定的某一行，然后检查程序的状态。调试器暂停（而非终止）的那个地方，被称之为断点（**breakpoint**）。



我们将使用 **GDB** （**G**NU **D**e**B**ugger）调试器来调试我们的内核。**gdb** 是程序的名称。**gdb** 主要完成以下 4 项工作：

- 启动程序，可以按照你的自定义的要求随心所欲的运行程序。
- 可让被调试的程序在指定的断点处暂停。
- 当程序被暂停时，可以检查此时程序中发生了什么事情。
- 你可以改变你的程序，可以尝试正确修复一个 **BUG** 后继续寻找另一个 **BUG**。



## 6.1 示例程序（A sample program）

要调试，就必须存在一个被调试的程序。该章节，我们继续使用 “Hello World” 程序作为示例程序：

```c
//hello.c

#include <stdio.h>

int main(int argc, char *argv[])
{
    printf("Hello World \n");
    
    return 0;
}
```



我们使用 **gcc** 的 **-g** 选项进行编译。（**-g** 表示带有调试信息）



```c
$ gcc -m32 -g hello.c -o hello
```



然后，我们启动 **gdb** 开始调试程序。（程序名作为命令行参数）



```c
$ gdb hello
```



## 6.2 静态检查程序（Static inspection of a program）

在程序运行时检查之前，**gdb** 会首先加载它到内存中（并不运行），此时可以检查很多有用的信息。这一小节的命令都可以用在程序运行之前。当然，这些命令也可以用在程序运行时，并显示更多的信息。



### 6.2.1 命令：info target/ info file/ info files

这个命令用于打印调试目标的信息。调试目标就是被调试的程序。



例 6.2.1 命令的输出来自 **hello** 程序：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_10-16-09.png)



以上输出内容详解：

- 符号文件的路径：包含调试信息的文件称之为 **符号文件** 。一般来说，它是二进制文件，但通常与可执行二进制文件分隔开来，它包含的调试信息分为 2 个文件，常用于远程调试。在示例中，对应内容如下：    **Symbols from "/home/hui/my_exercise/hello".**                           
- 调试程序的路径和它的文件类型。在示例中，对应内容如下：                                                                                **Local exec file:                                                                                                         `/home/hui/my_exercise/hello', file type elf32-i386.**                                                            
- 调试程序的入口。它是程序运行的第一个代码。在示例中，对应内容如下：	                                             **Entry point: 0x1060**
- 所有的节和它的起始和结束地址。在示例中，对应剩余的内容。



例 6.2.2 如果调试的程序运行在不同的机器中，它是个远程目标，而 **gdb** 仅打印一个简短的信息：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_10-59-18.png)

**注：** 因目前设备有限，该示例未进行验证。



### 6.2.2 命令：maint info sections

该命令类似于 **info target** 命令，它可以打印程序关于程序节的额外信息，特别是每个节的文件偏移和标志位。



例 6.2.3 再次运行 **hello** 程序，该命令输出结果如下：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_11-28-29.png)



输出类似于命令 **info target** 的输出，只是它更详细。紧挨着蓝色线右边的第一个为 **节的名称**，向右依次是 **节的标识**，用于描述 **节的属性**。这里，我们只关注带有 **LOAD** 标识的 **LOAD** 段。该命令可以与 **节的标识** 组合在一起，只输出指定的 **节**。



***ALLOBJ*** 显示所有加载的目标文件的 **节**，包括共享库。共享库只有在程序运行时才会显示。

 

例 6.2.4 只显示指定 **节**：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_11-45-11.png)



***section-flags*** 只显示指定 **节** 的标识。注意，那些指定 **节** 的标识是针对于 **gdb** 特定的，尽管它是基于前一章定义的 **节的属性**。当然，**gdb** 能识别带有以下标识（**flags**）的 **节**：



| 值                  | 含义                                                         |
| ------------------- | ------------------------------------------------------------ |
| ALLOC               | 该节在加载时会被进程分配空间。用于除包含调试信息外的所有节。 |
| LOAD                | 该节将被从文件中加载到子进程的内存中。用于预初始化的代码和数据，清除 **.bss** 节。 |
| RELOC               | 该节在加载时需要被重定位。                                   |
| READONLY            | 该节不能被子进程修改。                                       |
| CODE                | 该节只包含可执行代码。                                       |
| DATA                | 该节只包含数据。                                             |
| ROM                 | 该节将位于 **ROM** 中。                                      |
| CONSTRUCTOR         | 该节包含构造函数 / 析构函数的数据。                          |
| HAS_CONTENTS        | 该节不为空。                                                 |
| NEVER_LOAD          | 指向链接器使其不输出该节的指令。                             |
| COFF_SHARED_LIBARAY | 指向链接器的通知，该 **节** 包含 **COFF** 共享库信息。**COFF** 是一个目标文件格式，类似于 **ELF**。**ELF** 是可执行二进制文件的文件格式，**COFF** 是一个目标文件的文件格式。 |
| IS_COMMON           | 该节包含公共符号。                                           |



例 6.2.5 使用以下命令，将只显示包含命令的 **节**：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-00-39.png)



### 6.2.3 命令：info functions

该命令用于列出所有函数名和它们的加载地址。可以使用正则表达式过滤名称。



例 6.2.6 运行命令，输出显示如下：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-05-18.png)



### 6.2.4 命令：info variables

该命令用于列出所有全局和静态变量名称，也可以通过正则表达式过滤名称。



例 6.2.7 在之前的 **hello.c** 中添加一个全局变量 **int i**，重新编译并运行命令，输出如下：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-12-11.png)



### 6.2.5 命令：disassemble / disas

该命令用于显示可执行文件的汇编代码。



例 6.2.8 **gdb** 可以显示一个函数的汇编代码：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-15-39.png)



例 6.2.9 使用 **/m** 选项，将源代码一同显示：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-28-02.png)



图中蓝色框中的是源代码，每行源代码对应的汇编代码位于它的下方。



例 6.2.10 如果在上述命令行再加上可选项 **/r**，将以 16 进制显示指令的机器码，类似于 **objdump** 默认显示的汇编代码：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-36-41.png)



例 6.2.11 也可以显示指定某个文件中的某个函数：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-40-18.png)



**注**，文件名必须使用 **单引号** 包含，函数前面必须有 2 个冒号，如：**'hello.c'::main** 意思为显示 **hello.c** 文件中的 **main** 函数的汇编代码。



### 6.2.6 命令：x

 该命令用于检查给定内存范围的内容。



例 6.2.12 我们可以检查 **main** 函数的原始内容：

 ![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-47-45.png)



默认不带任何参数，命令只会打印单个内存地址的内容。这种情况下，通常是函数的开始内存地址。



例 6.2.13 带格式参数，命令可以根据格式参数打印一个范围的内存。

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-58-53.png)



**/20b** 是以 2 进制方式显示 20 个字节。

参数的格式是：**/<显示的字节数><显示的格式>**

如果不支持显示的字节数参数，则 **gdb** 默认支持显示 1 个字节。下表列出显示格式的取值：



| 值   | 含义                                        |
| ---- | ------------------------------------------- |
| o    | 八进制格式                                  |
| x    | 十六进制格式                                |
| d    | 十进制格式                                  |
| u    | 无符号十进制格式                            |
| t    | 二进制格式                                  |
| f    | 浮点格式                                    |
| a    | 内存地址格式                                |
| i    | 一系列汇编指令，类似于 **disassemble** 命令 |
| c    | 一组ASCII 字符                              |
| s    | 字符串                                      |



视情况而定，某些格式比其他格式更有利。如：如果内存域包含浮点数，则使用格式 **f** 显示会更好理解内容。



### 6.2.7 命令：print / p

检查内存是个很好的方式，如果能以更人性化的输出就再好不过了。刚好这个命令出现了，它以表达式打印。表达式可以是当前栈帧 / 函数 / 寄存器 /数字等等中的一个全局变量或一个局部变量。



## 6.3 动态检查程序（Runtime inspection of a program）

调试器主要用于在程序运行时，检查程序的状态。**gdb** 提供了一系列有用的命令 ，用于检索运行时信息。



### 6.3.1 命令：run / r

该命令用于开始运行程序。



例 6.3.1 运行 **hello** 程序：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_15-43-01.png)



程序运行成功，并打印 **Hello World** 信息。可是，如果 **gdb** 所能做的只是运行一个程序，那么它就没有什么用了。



### 6.3.2 命令：break / b

该命令用于在源代码中的某个位置设置一个断点。当 **gdb** 运行到断点位置时，它会暂停执行，以便程序员检查程序当前的状态。



例 6.3.2 可以在编辑器中对应的行上设置断点。假设我们在程序中 **main** 函数的开始位置，即第 3 行设置一个断点：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_16-05-59.png)



然后我们使用 **gdb** 启动调试，使用命令在第 3 行设置一个断点，然后再运行程序：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_16-14-13.png)



断点位于第 3 行，**gdb** 却暂停在第 5 行。原因是第 3 行没有包含代码，只是函数声明；**gdb** 只会暂停在可执行代码处。函数的开始执行代码位于第 5 行，调用 **printf** 处，因此 **gdb** 暂停在 第 5 行。



例 6.3.3 在行前打断点这种方式总是不可靠的，因为它会随着源代码修改而随之改变。如何才能让 **gdb** 暂停在 **main** 起始位置呢？这种情况下，可以直接使用函数名打断点：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_16-23-47.png)



可以看到，该方式在第 5 行打了个断点。跟命令 **"b 3"** 实现了同样的功能。这种方式的好处是，无论源代码如何修改，**gdb** 总是会在 **main** 处暂停。



例 6.3.4 有时候，**gdb** 调试汇编代码时，正在调试的程序是不需要包含调试信息的。在这种情况时，可以通过指定内存地址作为断点。可以使用 **print** 命令获取函数地址。

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_16-59-20.png)



知道了函数地址后，我们通过地址设置断点：（**该处验证有问题**）

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_17-16-58.png)



例 6.3.5 **gdb** 也可以在任何源文件中设置断点。假设 **hello** 程序是由多个源文件文件编译组成。如：hello1.c，hello2.c，hello3.c ...。这种情况时，可通过在行号或函数名前添加文件名设置断点：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_17-46-30.png)



### 6.3.3 命令：next / n

