# 第六章 运行时检查和调试

调试器是一个程序，它可以检查正在运行的程序。调试器可以启动和运行一个程序，并可以暂停在指定的某一行，然后检查程序的状态。调试器暂停（而非终止）的那个地方，被称之为断点（**breakpoint**）。



我们将使用 **GDB** （**G**NU **D**e**B**ugger）调试器来调试我们的内核。**gdb** 是程序的名称。**gdb** 主要完成以下 4 项工作：

- 启动程序，可以按照你的自定义的要求随心所欲的运行程序。
- 可让被调试的程序在指定的断点处暂停。
- 当程序被暂停时，可以检查此时程序中发生了什么事情。
- 你可以改变你的程序，可以尝试正确修复一个 **BUG** 后继续寻找另一个 **BUG**。



## 6.1 示例程序（A sample program）

要调试，就必须存在一个被调试的程序。该章节，我们继续使用 “Hello World” 程序作为示例程序：

```c
//hello.c

#include <stdio.h>

int main(int argc, char *argv[])
{
    printf("Hello World \n");
    
    return 0;
}
```



我们使用 **gcc** 的 **-g** 选项进行编译。（**-g** 表示带有调试信息）



```c
$ gcc -m32 -g hello.c -o hello
```



然后，我们启动 **gdb** 开始调试程序。（程序名作为命令行参数）



```c
$ gdb hello
```



## 6.2 静态检查程序（Static inspection of a program）

在程序运行时检查之前，**gdb** 会首先加载它到内存中（并不运行），此时可以检查很多有用的信息。这一小节的命令都可以用在程序运行之前。当然，这些命令也可以用在程序运行时，并显示更多的信息。



### 6.2.1 命令：info target/ info file/ info files

这个命令用于打印调试目标的信息。调试目标就是被调试的程序。



例 6.2.1 命令的输出来自 **hello** 程序：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_10-16-09.png)



以上输出内容详解：

- 符号文件的路径：包含调试信息的文件称之为 **符号文件** 。一般来说，它是二进制文件，但通常与可执行二进制文件分隔开来，它包含的调试信息分为 2 个文件，常用于远程调试。在示例中，对应内容如下：    **Symbols from "/home/hui/my_exercise/hello".**                           
- 调试程序的路径和它的文件类型。在示例中，对应内容如下：                                                                                **Local exec file:                                                                                                         `/home/hui/my_exercise/hello', file type elf32-i386.**                                                            
- 调试程序的入口。它是程序运行的第一个代码。在示例中，对应内容如下：	                                             **Entry point: 0x1060**
- 所有的节和它的起始和结束地址。在示例中，对应剩余的内容。



例 6.2.2 如果调试的程序运行在不同的机器中，它是个远程目标，而 **gdb** 仅打印一个简短的信息：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_10-59-18.png)

**注：** 因目前设备有限，该示例未进行验证。



### 6.2.2 命令：maint info sections

该命令类似于 **info target** 命令，它可以打印程序关于程序节的额外信息，特别是每个节的文件偏移和标志位。



例 6.2.3 再次运行 **hello** 程序，该命令输出结果如下：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_11-28-29.png)



输出类似于命令 **info target** 的输出，只是它更详细。紧挨着蓝色线右边的第一个为 **节的名称**，向右依次是 **节的标识**，用于描述 **节的属性**。这里，我们只关注带有 **LOAD** 标识的 **LOAD** 段。该命令可以与 **节的标识** 组合在一起，只输出指定的 **节**。



***ALLOBJ*** 显示所有加载的目标文件的 **节**，包括共享库。共享库只有在程序运行时才会显示。

 

例 6.2.4 只显示指定 **节**：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_11-45-11.png)



***section-flags*** 只显示指定 **节** 的标识。注意，那些指定 **节** 的标识是针对于 **gdb** 特定的，尽管它是基于前一章定义的 **节的属性**。当然，**gdb** 能识别带有以下标识（**flags**）的 **节**：



| 值                  | 含义                                                         |
| ------------------- | ------------------------------------------------------------ |
| ALLOC               | 该节在加载时会被进程分配空间。用于除包含调试信息外的所有节。 |
| LOAD                | 该节将被从文件中加载到子进程的内存中。用于预初始化的代码和数据，清除 **.bss** 节。 |
| RELOC               | 该节在加载时需要被重定位。                                   |
| READONLY            | 该节不能被子进程修改。                                       |
| CODE                | 该节只包含可执行代码。                                       |
| DATA                | 该节只包含数据。                                             |
| ROM                 | 该节将位于 **ROM** 中。                                      |
| CONSTRUCTOR         | 该节包含构造函数 / 析构函数的数据。                          |
| HAS_CONTENTS        | 该节不为空。                                                 |
| NEVER_LOAD          | 指向链接器使其不输出该节的指令。                             |
| COFF_SHARED_LIBARAY | 指向链接器的通知，该 **节** 包含 **COFF** 共享库信息。**COFF** 是一个目标文件格式，类似于 **ELF**。**ELF** 是可执行二进制文件的文件格式，**COFF** 是一个目标文件的文件格式。 |
| IS_COMMON           | 该节包含公共符号。                                           |



例 6.2.5 使用以下命令，将只显示包含命令的 **节**：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-00-39.png)



### 6.2.3 命令：info functions

该命令用于列出所有函数名和它们的加载地址。可以使用正则表达式过滤名称。



例 6.2.6 运行命令，输出显示如下：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-05-18.png)



### 6.2.4 命令：info variables

该命令用于列出所有全局和静态变量名称，也可以通过正则表达式过滤名称。



例 6.2.7 在之前的 **hello.c** 中添加一个全局变量 **int i**，重新编译并运行命令，输出如下：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-12-11.png)



### 6.2.5 命令：disassemble / disas

该命令用于显示可执行文件的汇编代码。



例 6.2.8 **gdb** 可以显示一个函数的汇编代码：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-15-39.png)



例 6.2.9 使用 **/m** 选项，将源代码一同显示：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-28-02.png)



图中蓝色框中的是源代码，每行源代码对应的汇编代码位于它的下方。



例 6.2.10 如果在上述命令行再加上可选项 **/r**，将以 16 进制显示指令的机器码，类似于 **objdump** 默认显示的汇编代码：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-36-41.png)



例 6.2.11 也可以显示指定某个文件中的某个函数：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-40-18.png)



**注**，文件名必须使用 **单引号** 包含，函数前面必须有 2 个冒号，如：**'hello.c'::main** 意思为显示 **hello.c** 文件中的 **main** 函数的汇编代码。



### 6.2.6 命令：x

 该命令用于检查给定内存范围的内容。



例 6.2.12 我们可以检查 **main** 函数的原始内容：

 ![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-47-45.png)



默认不带任何参数，命令只会打印单个内存地址的内容。这种情况下，通常是函数的开始内存地址。



例 6.2.13 带格式参数，命令可以根据格式参数打印一个范围的内存。

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_14-58-53.png)



**/20b** 是以 2 进制方式显示 20 个字节。

参数的格式是：**/<显示的字节数><显示的格式>**

如果不支持显示的字节数参数，则 **gdb** 默认支持显示 1 个字节。下表列出显示格式的取值：



| 值   | 含义                                        |
| ---- | ------------------------------------------- |
| o    | 八进制格式                                  |
| x    | 十六进制格式                                |
| d    | 十进制格式                                  |
| u    | 无符号十进制格式                            |
| t    | 二进制格式                                  |
| f    | 浮点格式                                    |
| a    | 内存地址格式                                |
| i    | 一系列汇编指令，类似于 **disassemble** 命令 |
| c    | 一组ASCII 字符                              |
| s    | 字符串                                      |



视情况而定，某些格式比其他格式更有利。如：如果内存域包含浮点数，则使用格式 **f** 显示会更好理解内容。



### 6.2.7 命令：print / p

检查内存是个很好的方式，如果能以更人性化的输出就再好不过了。刚好这个命令出现了，它以表达式打印。表达式可以是当前栈帧 / 函数 / 寄存器 /数字等等中的一个全局变量或一个局部变量。



## 6.3 动态检查程序（Runtime inspection of a program）

调试器主要用于在程序运行时，检查程序的状态。**gdb** 提供了一系列有用的命令 ，用于检索运行时信息。



### 6.3.1 命令：run / r

该命令用于开始运行程序。



例 6.3.1 运行 **hello** 程序：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_15-43-01.png)



程序运行成功，并打印 **Hello World** 信息。可是，如果 **gdb** 所能做的只是运行一个程序，那么它就没有什么用了。



### 6.3.2 命令：break / b

该命令用于在源代码中的某个位置设置一个断点。当 **gdb** 运行到断点位置时，它会暂停执行，以便程序员检查程序当前的状态。



例 6.3.2 可以在编辑器中对应的行上设置断点。假设我们在程序中 **main** 函数的开始位置，即第 3 行设置一个断点：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_16-05-59.png)



然后我们使用 **gdb** 启动调试，使用命令在第 3 行设置一个断点，然后再运行程序：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_16-14-13.png)



断点位于第 3 行，**gdb** 却暂停在第 5 行。原因是第 3 行没有包含代码，只是函数声明；**gdb** 只会暂停在可执行代码处。函数的开始执行代码位于第 5 行，调用 **printf** 处，因此 **gdb** 暂停在 第 5 行。



例 6.3.3 在行前打断点这种方式总是不可靠的，因为它会随着源代码修改而随之改变。如何才能让 **gdb** 暂停在 **main** 起始位置呢？这种情况下，可以直接使用函数名打断点：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_16-23-47.png)



可以看到，该方式在第 5 行打了个断点。跟命令 **"b 3"** 实现了同样的功能。这种方式的好处是，无论源代码如何修改，**gdb** 总是会在 **main** 处暂停。



例 6.3.4 有时候，**gdb** 调试汇编代码时，正在调试的程序是不需要包含调试信息的。在这种情况时，可以通过指定内存地址作为断点。可以使用 **print** 命令获取函数地址。

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_16-59-20.png)



知道了函数地址后，我们通过地址设置断点：（**该处验证有问题**）

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_17-16-58.png)



例 6.3.5/6 **gdb** 也可以在任何源文件中设置断点。假设 **hello** 程序是由多个源文件文件编译组成。如：hello1.c，hello2.c，hello3.c ...。这种情况时，可通过在行号或函数名前添加文件名设置断点：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-23_17-46-30.png)



### 6.3.3 命令：next / n

该命令执行当前行，并在下一行暂停。如果当前行是一个函数调用，则直接执行完它暂停在下一行。



例 6.3.7 在 **main** 函数设置一个断点，运行程序，并停在 **printf** 行。然后执行命令 **next** :

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-24_09-27-38.png)



上图中，执行完 **next** 命令后，输出的第一行是执行完 **printf** 函数打印的信息，第二行是 **gdb** 当前暂停的位置，即第 6 行。



### 6.3.4 命令：step / s

该命令与 **next** 命令相似，也是执行完当前行之后，在下一行暂停。不同的是，如果当前行是函数调用，则该命令会进入调用函数内部，并暂停在调用函数的第一行。



例 6.3.8 修改 **hello.c** 源代码，添加函数调用：

```c
//hello.c

#include <stdio.h>

int add(int a, int b)
{
    return a + b;
}

int main(int argc, char *argv[])
{
    add(1, 2);
    printf("hello world \n");
    
    return 0;
}
```





编译之后，使用 **gdb** 调试，先在 **main** 函数设置个断点，然后运行程序，最后使用 **step** 命令替换 **next** 命令：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-24_09-44-44.png)



由上图可知，在执行完 **step** 命令后，**gdb** 进入了 **add** 函数内部，并暂停在了函数的第一行。



### 6.3.5 命令：ni

宏观来看，**gdb** 是逐行执行的，这种显示会对程序员比较友好。而实际上，从微观来看，**gdb** 内部操作的是汇编指令。 一条 **C** 语句都被转换为一条或多条汇编指令，可以通过 **objdump** 和 **disassemble** 命令查看汇编语句。 

有了调试信息，**gdb** 就可以知道有多少行汇编指令属于 **C** 的一行源代码；逐行调试时就是执行属于当前行的所有汇编代码，并暂停在下一行的汇编代码开始处。



该命令执行属于当前行的一条汇编指令。直到属于当前行的所有汇编指令全部执行完，**gdb** 才会执行下一行。如果当前行是一个调用，则执行完调用后暂停在下一条指令。



例 6.3.9 在 **printf** 处设置断点，并使用 **ni** 命令，它将逐条执行汇编指令：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-24_10-26-45.png)



由上图可知，**ni** 命令是逐个执行汇编指令，并显示下一个要执行的汇编指令。那要怎么知道当前执行的汇编指令呢？可以使用 **x/i $eip** 命令查看当前执行的汇编指令，如上图中蓝色框中所示。



### 6.3.6 命令：si

类似于 **ni** 命令，不同之处在于，如果当前行是一个调用，则该命令会进入调用函数，并暂停在调用函数的第一条汇编代码处。



例 6.3.10 **printf** 函数的汇编代码中存在调用，使用 **si** 命令进入调用函数：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-24_11-00-40.png)



由上图可以看出，在地址 0x565561be 是个调用，使用 **si** 命令可以进入调用，地址 0xf7e4a470 就是调用函数的第一条代码。在上图中绿色框中显示。



### 6.3.7 命令：until

该命令会使 **gdb** 一直执行，直到下一行的行号大于当前行时暂停在下一行。



例 6.3.11 修改 **hello.c** 源代码，使其包含一个循环：

```c
//hello.c

#include <stdio.h>

int add1000()
{
    int total = 0;
    
    for (int i=0; i<1000; i++) {
        
        total += i;
    }
   
    printf("Done adding \n");
    
    return total;
}

int main(int argc, char *argv[])
{
    add1000();
    printf("Hello World \n");
    
    return 0;
}
```



编译完后，使用 **gdb** 进行调试，如果使用 **next** 命令，我们需要按 1000 次才能完成该循环，因此 ，**until** 命令横空出世，解放了你的双手：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-24_11-29-50.png)



由上图可知：只需要按 4 次 **until** 命令就可以执行完 1000 次循环。

第 1 次运行 **until** 命令，**gdb** 暂停在第 7 行（因为 7 > 5）。

第 2 次运行 **until** 命令，**gdb** 暂停在第 9 行（因为 9 > 7）。

第 3 次运行 **until** 命令，**gdb** 暂停在第 7 行（是因为循环仍在继续）。因为 7 < 9，则第 4 次运行 **until** 命令时，**gdb** 将会一直运行，直到它不会再回到第 7 行 ，因此暂停在第 12 行。这是跳过中间循环的好方法，替代了为了跳出循环而设置的不必要的断点。



例 6.3.12 通过参数显式的执行到指定行：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-24_13-41-09.png)



### 6.3.8 命令：finish

该命令一直执行到函数结束并显示会返回值。**finish** 命令实际上就是 **until** 命令的便捷版。



例 6.3.13 使用上例中的源代码，在 **add1000** 函数处设置断点，然后使用 **finish** 命令替代 **until** 命令。

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-24_13-54-39.png)



### 6.3.9 命令：bt

该命令用于打印栈帧的回溯。回溯即当前活动函数的列表。（类似于递归调用）



例 6.3.14 修改 **hello.c** 源代码，增加函数调用。代码如下：

```c
//hello.c

void d(int d) { };
void c(int c) { d(0); }
void b(int b) { c(1); }
void a(int a) { b(2); }

int main(int argc, char *argv[])
{
    a(3);
    
    return 0;
}
```



编译完后，使用 **gdb** 调试，运行 **bt** 命令，可以看到调用的关系：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-24_14-10-36.png)



由上图可知：越近调用越靠上，越远调用越靠下。在这种情况下，**d** 函数是当前活动的函数，因此它的索引为 0（即 **#0** ）。紧接着第 2 活动函数是 **c** 函数，索引为 1。后面依次是 **b**，**a** 函数。最底部是 **main** 函数。这就是我们读取回溯的方式。



### 6.3.10 命令：up

该命令可以查看当前帧的前一帧。（**注**： 书上该指令讲解有误，需注意）



例 6.3.15 使用 **up** 命令查看当前帧的前一帧。

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-24_14-26-25.png)



### 6.3.11 命令：down

跟 **up** 命令类似，不过该命用于查看当前帧的下一帧。（**注**： 书上该指令讲解有误，需注意）



例 6.3.16 使用 **down** 命令查看当前帧的下一帧。

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-24_14-33-55.png)



### 6.3.11 命令：info registers

该命令用于列出通用寄存器中的当前值。在调试汇编和操作系统代码时，该命令特别方便，我们可以使用该命令查看当前机器的状态。



例 6.3.17 运行命令，我们可以看到通用寄存器的当前值：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-05-24_14-42-37.png)



上图中的这些寄存器，足够我们后面编写操作系统使用。



## 6.4 调试器如何工作：简短的介绍（How debugger work: A brief introduction）

### 6.4.1 断点如何工作（How breakpoints work）

当在程序中某处设置了个断点，实际上是在语句的第一条指令的第一个操作码被另一条指令（指令为 int 3，操作码为 CCh）替换：

如下图：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-06-12_18-29-25.png)

**int 3** 指令仅耗费一个字节，这使得调试效率很高。当 **int 3** 指令被执行，操作系统将调用断点中断处理函数。它将检查哪个进程执行到了断点并暂停它，然后通知调试器它已暂停调试的进程。被调试的进程只能暂停，这意味着调试器可以自由地检查其内部状态，就像外科医生给麻醉病人做手术一样。然后，调试器用原始操作码替换 **int 3** 操作码，并正常执行原始指令。

如下图：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-06-12_18-37-22.png)

例 6.4.1 很容易看出 **int 3** 指令的作用。首先，我们在需要 **gdb** 停止的地方添加一个 **int 3** 指令：

```c
//hello.c

#include <stdio.h>

int main(int argc, char *argv[])
{
    asm("int 3");
    printf("Hello World \n");
    
    return 0;
}
```



**int 3** 位于 **printf** 之前，因此预期 **gdb** 会暂停在 **printf** 处，接下来，我们编译并调试运行代码：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-06-13_17-28-35.png)



由上图可知，**gdb** 遇到了一个断点，并暂停在预期的位置（预期位置：**printf** 处）。



### 6.4.2 单步执行（Single stepping）

当实现了断点之后，实现单步执行就很简单了，调试器只需要在下一条指令处简单的用 **int 3** 替换即可。因此，当程序员在一个指令处设置了个断点，则调试器自动在下一条指令处使用 **int 3** 指令进行替换，这样就可以实现单步调试。同样，逐行调试是在两行语句的第一个操作码使用 **int 3** 指令替换。



### 6.4.3 调试器如何识别高级源代码（How a debugger understands high level source code）

**DWARF** 是一种调试文件格式，许多编译器和调试器使用它来支持源代码级别的调试。**DWARF** 包含可执行二进制文件中的实体与源代码文件之间的映射信息。程序实体可以是数据或者代码。**DIE** ，即调试信息入口（**D**ebugging **I**nformation **E**ntry），用于描述程序实体。一个 **DIE** 由一个 **DIE** 指定的实体的 **tag** 和 一个描述实体的属性列表组成。在所有的属性中，以下两个属性用于使能源码级别调试：

- **WHERE THE ENTRY APPEARS IN THE SOURCE FILES** ：指示实体出现在哪个文件的哪一行。
- **WHERE THE ENTRY APPEARS IN THE EXECUTABLE BINARY** ：在运行时，实体被加载到的内存地址。有了准确的地址后，**gdb** 就能从数据实体得到到正确的值，或将断点放在正确的位置并暂停在对应的代码实体。如果没有这些地址信息，**gdb** 将无法知道要检查的实体在什么地址。



下图使用 DIE 显示源代码和可执行文件的映射关系：

![](E:\Work\OS\toy_os\pictures\Part 6\Snipaste_2019-06-13_18-41-44.png)



除此之外，另个源代码和可执行二进制映射是 **行号表** 。**行号表** 映射着源代码中的行对应到可执行二进制中改行的内存起始地址。









