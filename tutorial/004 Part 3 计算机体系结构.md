# 第三章 计算机体系结构



要编写较底层的代码，程序员必须了解计算机的架构。就好像程序员在软件框架中编写程序时，他必须知道框架会能够解决什么样的问题，以及如何通过其提供的接口来使用框架。



但在了解计算机体系结构的定义之前，我们必须了解计算机究竟是什么，因为许多人仍然认为计算机是我们放在桌面上的常见计算机，或者充其量只是服务器。计算机有各种形状和大小，人们从来不会想到那就是计算机，也不会想到代码可以跑在这样的设备上。





## 3.1 什么是计算机



计算机是一种硬件设备，至少包括处理器（CPU），计算机存储设备和输入/输出接口。所有的计算机都可以分为两种类型



+ 专用计算机

  专用计算机是一种为完成特定任务而建立在硬件水平的计算机。举栗子：

  + 单用途：encoder / decoder；时间，图像/视频/音频处理器



+ 通用计算机

  通用计算机是一种可编程的（不用修改硬件）计算机。这种计算机用来模仿各种专用计算机的功能。



### 3.1.1 Server



服务器是一种通用的高性能计算机，具有巨大的服务器资源，可为广大客户提供大规模服务（客户是指那些通过个人设备连接服务器的人）。



![](https://upload-images.jianshu.io/upload_images/15548795-b0cce0b1df47242e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 3.1.2 台式计算机



台式计算机是一台通用计算机，具有为人类用户设计的输入和输出系统。具有足够给个人使用的资源。

输入系统通常包括鼠标和键盘，而输出系统通常包括一个可以显示高像素的显示器。计算机封装在一个机箱中，足以放置各种计算机组件，如处理器，主板，电源，硬盘等。



![](https://upload-images.jianshu.io/upload_images/15548795-d88c1af1812179f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 3.1.3 便携式计算机



便携式计算机类似于具有较少资源的台式计算机，但可以随身携带。



![](https://upload-images.jianshu.io/upload_images/15548795-97d1dd2b71325724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 3.1.4 游戏机



游戏机类似于台式计算机，但针对游戏进行了优化。游戏控制台的输入系统不是键盘和鼠标，而是游戏控制器，它是一个带有几个用于控制屏幕上物体的按钮的设备，输出系统是显示屏。



游戏机使用定制的处理器和图形处理器，但类似于台式计算机。例如，第一台 Xbox 使用定制的 Intel PentiumIII 处理器。



![](https://upload-images.jianshu.io/upload_images/15548795-1a7a2304bf0202fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



手持游戏机与游戏机类似，但是手持游戏机把整个输入输出设备和计算机都包在了一起。



![](https://upload-images.jianshu.io/upload_images/15548795-975bf41d19884686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





### 嵌入式计算机



嵌入式计算机是单板计算机或单芯片计算机，它们只有有限的资源，为整合到大型硬件中设计出来。



*微控制器*是一种嵌入式计算机，用于控制微控制器的其他硬件设备。微控制器安装在芯片上。微控制器是通用计算机，但资源有限，因此它只能执行一项或几项专门任务。这些计算机仅用于一个目的，但它们仍然是通用的，因为它们可以根据需要对它们进行编程以执行不同的任务，而无需更改底层硬件。



![](https://upload-images.jianshu.io/upload_images/15548795-c5f80f20d098f228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



另一种类型的嵌入式计算机是 system-on-chip。system-on-chip 是单个芯片上的完整计算机。



虽然微控制器也安装在芯片上，但其目的却不同。微控制器通常更简单并且在硬件资源方面更受限制，因为在运行时仅专门用于一个目的。



而 system-on-chip 是可以用于多种目的的通用计算机。system-on-chip 可以像常规台式计算机一样运行，能够加载操作系统并运行各种应用程序。片上系统通常存在于智能手机中，例如在 Ipad2 和iPhone 4S 中使用的 Apple A5 SoC，或在许多 Android 手机中使用的 Qualcomm Snapdragon。



![](https://upload-images.jianshu.io/upload_images/15548795-3f1bdeb958beef87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



无论是微处理器还是 system-on-chip。他们都需要搭载在一个环境上，以连接其他设备。这种环境是一种电路板叫做 PCB（Printed Circuit Board）。



印刷电路板（PCB）包含线能够使电子设备上流动。没有 PCB 也就不能联合所有设备，也就不能创建一个更大的设备。



嵌入式设备，是大型设备的一份子，帮助大型设备在更高层次的完成更高目标。给嵌入式设备写代码就叫做嵌入式编程。嵌入计算机被用来自动控制像电动工具，植入医疗设备，办公设备，引擎控制系统，家电，远程控制系统和其他嵌入式系统。





老实说，微处理器和 system-on-chip 的界限很模糊。如果硬件保持升级，那么微处理器可以得到足够的资源跑一个操作系统，用来处理多个特定的任务。相反，system-on-chip 也有足够的能力胜任微控制器的任务。



然而，把 system-on-chip 当做微控制器真的不是一个性价比很高的选择，而且会浪费很多硬件资源。因为给微控制器写软件会需要一些计算资源。



### 3.1.6  可编程门阵列 （Field－Programmable Gate Array）



可编程门阵列 （FPGA）是一种包含一组可重新定制门的硬件。也就是说，当这个硬件从工厂里出来以后，它的电路结构还是可编程的。想想之前的章节，每一个 74HC00 芯片可以被当做一个门。一个复杂的设备可以由多个 74HC00 芯片组合成。



相似的是，每一个 FPGA 设备。包含成百上千的芯片，这些芯片叫做逻辑块（logic blocks）。这是一种比 74HC00 复杂的多的芯片，它也可以实现布尔逻辑函数（Boolean logic function）。这些连在一起的逻辑块能够创建高级硬件的功能。这些高级的功能通常是一种需要高速处理的专用算法。



![](https://upload-images.jianshu.io/upload_images/15548795-637076829ce9fe7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

数字设备可以通过组合逻辑门来设计，不需要涉及实际的电路部件，因为物理电路只是多个 CMOS 电路。数字硬件，包括计算机中的各种组件，是通过编写代码而设计的，就像常规程序员一样，通过使用语言来描述门是如何连接在一起的。这种语言称为**「硬件描述语言」**（Hardware Description Language）。之后，硬件描述被编译为连接的电子组件的描述 ，被叫做 *netlist*，是一种对门电路更详细的描述。



FPGA 与其他嵌入式计算机之间的区别在于 FPGA 中的程序是在数字逻辑级实现的，而嵌入式计算机中的程序，如微控制器或片上系统设备则是在汇编代码级实现的。为 FPGA 器件编写的算法是对逻辑门中的算法的描述，然后 FPGA 器件遵循描述配置自身，以达到执行算法的目的。为微控制器编写的算法是汇编指令，处理器可以理解并采取相应的行动。





FPGA 适用于在常规计算机上运行的专用操作，且不适合成本高昂的情况，例如实时医学图像处理，巡航控制系统等等。这些应用程序需要使用常规处理器无法实现的高速处理，因为处理器在执行许多非专用指令（可能会增加数千条指令或更多指令）时浪费了大量时间来实现这样的的操作，因此在完成相同操作的时候需要更多的物理电路。FPGA 设备不能承受这样的开销，相反，它只运行一个直接在硬件中实现专门的操作。





### 3.1.7 专用集成电路



一个专用集成电路（Application-Specific Integrated Circuit）是一种用于特定目的而不是用于通用目的的芯片。



ASIC 不包含通用的逻辑块阵列，不能够重新配置以适应任何类似 FPGA 的操作。相反，每一个在 ASIC 的逻辑块都是为自身电路存在的。FPGA 可以被认为是ASIC的原型阶段，而 ASIC 则是电路生产的最后阶段。



ASIC 比 FPGA 更专用，所以它有更高的性能。然而，ASIC 对制造产商来说非常昂贵。一旦被制作出来，只要发生任何设计错误，一切都化为泡沫。这一点不像 FPGA ，FPGA 可以被简单地重新编程。



## 3.2 计算机架构



上一节研究了各类计算机。无论形状和尺寸如何，每台计算机都有它从高层到底层的意义。



`计算机架构 = 指令集架构 + 计算机组成 + 硬件`



最高层是`指令集架构`（ Instruction Set Architecture.）

中层是`计算机组成`（Computer Organization）

最底层是`硬件`（Hardware）





现在分开解释这些名词的含义。



### 3.2.1 指令集架构



`指令集`是微处理器能够理解并可以执行的基本命令集合。



`指令集架构`（Instruction Set Architecture）或者叫做 ISA，是实现指令集的环境设计。本质上，ISA 就是一种类似现在高级语言解释器的运行环境。`指令集架构`的设计包括所有的指令，寄存器，中断，内存模型（内存如何被程序使用和安排），地址模型，I/O 等等一些跟 CPU 有关的特性。CPU 有更多的功能，就有需要实现更多的电路。





### 3.2.2 计算机组成

计算机组成是计算机设计的功能视图。计算机组成在这个视图中，计算机的硬件组件呈现为具有输入和输出的盒子，它们相互连接并形成计算机的设计。两台计算机可能具有相同的 ISA，但具有不同的组成。例如，AMD 和 Intel 处理器都实现了x86 ISA，但构成 ISA 环境的每个处理器的硬件组件并不相同。



计算机组成随着产商的设计不同而不同，但是他们有同一个源头——冯·诺依曼体系结构（Von Neumann architecture）。



![](https://upload-images.jianshu.io/upload_images/15548795-0f19367824da777f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

CPU 不断的从主存里面拿到指令并执行。



* *内存*（Memory）可以存储程序和代码

+ *总线*（Bus）是一种在上述组件之间发送 bit 的电线
+ *I/O 设备* （Input and Output）是为计算机提供输入输出的设备



冯诺依曼（Von-Neumann）计算机通过将其指令存储在主存中来操作，并且 CPU 反复将这些指令一个个取出并存入内部存储器中以便执行。数据通过 CPU，存储器和 I/O 设备之间的数据总线传输，存储在设备中的位置由 CPU 通过地址总线传输。这种架构完全实现了*获取 - 解码 - 执行* 的循环。



早期的计算机，完全按*冯诺依曼计算机*来实现的，有 CPU，内存，I/O 设备并在相同的总线中交互。如今，计算机有更多的总线，每一种总线都有它特定的功能。然而，核心来看，他们仍然是冯诺依曼机器。为了写一个冯诺依曼机器的操作系统，程序员必须能够读懂并写出那些能够控制核心组件的代码：CPU、内存、I/O 设备和总线。



**CPU**（Central Processing Unit）是任何计算机的核心。理解 CPU 对写一个操作系统非常重要。





+  为了使用这些设备，一个程序员需要控制 CPU 去使用其他设备的编程接口。使用CPU 就是唯一的办法，因为 CPU 就是程序员能够直接使用的设备，而且是唯一能够理解程序员代码的设备。

  

+ 在 CPU 里面，许多操作系统概念已经直接在硬件中实现，例如任务切换，分页。内核程序员需要知道如何使用硬件功能，以避免在软件中重复这样的概念，从而浪费计算机资源。



+ CPU 内置操作系统功能可提高操作系统性能和开发人员生产力，因为这些功能就是实际的硬件，最底层的东西。程序员当然可以用这些东西。



+ 为了高效的使用 CPU，程序员应该能够读懂来自硬件厂商的文档。比如：`Intel®64 and IA-32 Architectures Software Developer Manuals`



+ 学会一个 CPU 架构，很容易学会其他架构。



 CPU 就是 ISA 的实现，高效的实现汇编语言（可能 CPU 的架构不同，语言可能不同）。汇编语言是软件工程师控制 CPU 的接口，通过控制CPU从而控制计算机。



但是，如何只使用 CPU 访问每台计算机的所有设备？简单的答案是 CPU 可以通过这两个接口与其他设备通信，从而命令它们：



+ 寄存器（Registers）

  寄存器是一种能够高速访问数据的硬件，而且可以和其他应硬件设备交互。寄存器允许软件直接通过写入设备的寄存器来控制硬件，或者从设备的寄存器读取时，获取硬件的信息。

  

  并非所有寄存器都用于与其他设备通信。在 CPU 中，大多数寄存器用作临时数据的高速存储。其他的可以和 CPU 交互的设备，通常有一组给 CPU 交互的寄存器。



+ 端口（Port）

  端口是硬件设备中专用的寄存器，被用来和其他设备交互。当数据被写入一个端口的时候，硬件会根据值的不同做出不同的反应。端口（port）和寄存器（Registers）的最大不同是，寄存器不存储数据，而是将数据委托给其他电路。



这两种接口都非常重要，因为他们是软件操纵硬件的唯二接口。写设备驱动本质上就是学习每个寄存器的功能，以及为了控制硬件如何使用这些寄存器。



内存（Memory）是一种存储设备。内存包括很多的单元，每个单元都有它的地址。所以一个 CPU 可以使用这些地址访问内存单元。内存是软件存储指令（机器语言）的地方，可以被 CPU 检索和执行。内存也可以存储被软件所需的数据。



内存在冯诺依曼机器中，不区分数据和指令，那由软件自己决定。如果以某种方式获取数据字节并作为指令执行，而且这些字节代表有效指令，CPU 就会执行，而且可能会产生不良结果。对于一个 CPU 来说，没有代码和数据。他们都是不同的数据类型，一个告诉 CPU 做什么，另一个是 CPU 搞事情的时候必备的材料。





内存控制器（memory controller）控制着 RAM。现如今，大多数处理器都有这样的设备。所以 CPU 也有专门的内存总线与 RAM 连接。在老型号的 CPU 中，RAM 被搭在一个叫做 MCH（Memory Controller Hub）的芯片上。这样的话， CPU 不是与 RAM 直接交互，而是 MCH 芯片上。然后这个芯片与内存交互，读或写入数据。

当然，现在的 CPU 性能更好，因为 CPU 和内存交互的过程中没有中间商（做差价。。。）



![](https://upload-images.jianshu.io/upload_images/15548795-b73819f7b084b5cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



![](https://upload-images.jianshu.io/upload_images/15548795-728861cdc8b40cc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



在物理层面，RAM 由一系列单元网格实现，每个单元网格包含一个晶体管和一个电容（capacitor），每个单元网格只能短时间存储数据。并且，晶体管控制对电容的访问。当接通时，它允许从电容器读取或写入少量电荷。在电容器上的电荷缓慢流失，需要不断刷新电路不断从单元中读取数据经外部电源放大后写回其单元中。





*总线（bus）* 是一个能够在不同计算机硬件甚至是计算机间传递数据的子系统。物理层面上来说，总线只是能够连接所有计算机硬件的电线，并且能传递大量数据。



总线的总个数叫做*总线的带宽（bus width）*，取决于 CPU 能够支持几根线。如果一个 CPU 只能同时接受 16 位，那么总线有 16 根连接着硬件和 CPU，也意味着 CPU 只能同时能处理 16 位的数据。



### 3.2.3 硬件

硬件就是计算机的具体实现，一系列处理器实现相同的指令集架构并使用几乎相同的组成，但在硬件实现方面有所不同。



举个栗子：o(≧口≦)o



酷睿 i7 系列提供给台式机是性能更好但是更耗能的模型，然而其他给笔记本的模型是节能但是性能较低的模型。为了给硬件写代码，如果硬件产商的文档可供查阅的话，我们是不必去理解硬件是怎么实现的。计算机组成以及尤其是指令集架构与操作系统程序员更相关。因为此，在下一章的时候，我将教你深入理解 x86 指令集



## x86 架构



*芯片组（chipset）*是有很多功能的芯片。历史上来讲，芯片组就是一组独立的芯片，每一个芯片都有自己的功能。



比如：内存控制器，图形控制器，网络控制器，电力控制器等等



随着硬件的发展，这一组芯片被整合到单个芯片中了，因此变得更猛更便宜了。在台式机中，不同的硬件设备通过主板（motherboard）相连。每一个 CPU 需要可兼容自己的主板。每一块主板都是由它的芯片组定义的。而且这个芯片组决定了 CPU 可以控制的环境。这个环境包括：



+ 一个或多个给 CPU 的插槽
+ 由南桥和北桥组成的芯片组
  + 北桥芯片负责 CPU，主存和显卡之间的高性能通信
  + 南桥芯片负责与 I/O 设备和其他对性能要求不高的设备进行通信
+ 内存条的插槽
+ 显卡的插槽
+ 其他设备的通用插槽，例如网卡，声卡

+ I/O 设备的端口，比如键盘鼠标 USB



为了写这样一个完整的操作系统，程序员需要知道如何给这些设备编程。毕竟，在所有的组成中，学习如何给 CPU 编程还是最重要的，因为这是计算机中最重要的组成部分。因为这，这本书最初的目的还是教你如何在 x86 CPU 上编程。哪怕只聚焦于 CPU，一个合理的极小的操作系统也是可以写出来的。原因是，不是所有的的计算机都有像台式机那样的设备。



举个栗子：一个嵌入式的计算机，可能只有一个 CPU 而且内存有限，只有输入输出的引脚。但是它也有操作系统啊！



然而，学习如何在 x86 CPU 上编程是一个艰巨的任务。它有三个重要的手册：500 页的第一卷，2000 多页的第二卷，1000 多页的第三卷。程序员如果能掌握 x86 CPU 编程的各个方面，这是一个令人印象深刻的壮举。





我们来看看它的主板设计：

![](https://upload-images.jianshu.io/upload_images/15548795-8272e8a361f3be93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



## 3.4 Intel Q35 芯片组



Q35 是 2007 年 9 月发布的英特尔芯片组。Q35 用作高级计算机组成的示例，因为稍后我们将使用 QEMU 模拟 Q35 系统，这是 QEMU 最新的英特尔系统。虽然 Q35 在 2007 年发布，但它对于当前的硬件来说相对现代，而且知识仍可以重用于当前的芯片组模型。使用 Q35 芯片组，仿真 CPU 也具有当前 CPU 中提供的功能，因此我们可以使用英特尔最新的软件手册。



上面那个大图，是当今典型的计算机主板结构，Q35 也有这样的构造。



## 3.5  x86 运行环境



*执行环境（execution environment）*是一种能让代码运行的环境。执行环境需要解决下面的问题



+ 支持的操作？数据传输，计算，控制，浮点等
+ 操作数存储在哪里？寄存器，存储器，堆栈，累加器

+ 每个指令有多少显式操作数？0 1 2 或者 3
+ 支持哪种类型和大小的操作数？字节，整形，浮点，双精度，字符串，向量
+ 等等



有关本章的内容，请继续阅读英特尔手册第 1 卷“基本执行环境”中的第 3 章。



第三章结束。完结撒花。



![](https://upload-images.jianshu.io/upload_images/15548795-2a6c20a9dbf030c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)