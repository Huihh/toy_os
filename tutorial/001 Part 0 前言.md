# 操作系统从 0 到 1



## 前言



哈喽！



你可能不止一次地问过自己如何从头开始编写一个操作系统，甚至你可能已经有了数年的编程经验，对操作系统的理解却依然只限于一组抽象概念，而不知其具体实现。对于那些从未编写过操作系统的人来说，操作系统无异于黑魔法：操作系统可以通过编程语言中的 API 来理解程序员的请求，进而对硬件进行控制，堪称是一件奇物。学习编写操作系统听起来十分吓人，感觉就好像无论学了多少知识都不够一样。因此你现在阅读本书可能是为了对操作系统有一个更好的理解，想要成为一个牛逼的软件工程师。



**如果你就是我上面说的那类朋友，那么本书就是为你打造的**。学完本书，你将学到一些你所不知道但却很重要的知识，正是这些知识让你能够从零开始实现你自己的操作系统。是的，你没听错，真正的**从零开始**！没有任何现成的操作系统层哦~证明你能不能胜任操作系统开发者身份的时候到了！



你可能会问：“学习 Linux 的系统内部机制不是更实际吗？”



是……  

但也不是



学习 Linux 有助于你的日常工作流，但是如果你仅仅是使用现有的操作系统，就永远也不可能写出一个真正的操作系统。通过编写一个你自己的操作系统，你所获得的是你单纯学习 Linux 时学不到的知识。



以下列出了你学习编写操作系统部分的好处：



+ 你将了解到计算机在硬件层面上是怎样运作的，还将学会编写可以直接对硬件进行操作的软件
+ 你将学到操作系统的基础知识，这些知识可以使你轻松驾驭任何操作系统，而不仅仅是 Linux
+ 要想如愿入侵 Linux 系统，你至少需要自己编写一个操作系统。这就好比编写应用软件一样：想要搞波大的，就得先造个简单的
+ 你将接触到各种底层开发领域：逆向工程，漏洞利用，构建虚拟机，游戏控制台模拟器，等等。汇编语言将成为你进行底层分析最必不可少的工具（**请注意**，这并不意味着你一定用汇编来写操作系统）
+ 最后一点最重要：写操作系统很好玩！



### 为啥不看别的妖艳贱货咧？



现在已经有很多关于这个主题的书籍和课程了，并且这些教程都由知名教授和专家制作，我又何德何能写一本主题如此艰深的书？我要说的是，虽说确实存在许多优质资源，但很遗憾，他们都有点儿缺斤少两。

有哪一本书告诉你如何不依赖现成的操作系统来编译 C 代码和 C 运行时库吗？大多数关于操作系统设计和实现的书籍都只讨论了软件方面的内容，却忽略了操作系统与硬件的交互过程。重要的硬件细节被略过，而自学者却很难在网上找到这方面的资源。

本书的目的就是要弥补这方面的缺陷。你不仅仅会学到如何直接在硬件上编程，还会学到如何通过阅读硬件厂商的官方文件来编程。你不再需要求爷爷告奶奶地四处寻找资源来帮助自己理解硬件手册和文档：你自己就可以做到了。

最后，我是以自学者的角度来写这本书的。我会尽量写得详尽一点，这样你就可以节省下推测、搜寻信息的时间，把更多时间用在学习上。



本书焦点之一是教你通过阅读官方文档来实现自己的软件。这些来自硬件厂商（比如 Intel）的官方文档对于编写操作系统或跑在裸机上的软件是极其重要的。退一万步讲，一个操作系统开发者至少要能理解官方文档，能够按照官方文档实现软件的功能。因此，第一章就用来讨论相关文档及其重要性。



本书的另一个显著特征是“易于上手”。书中大多数示例都是类似 “Hello World” 这样的简单程序。以便让你熟悉一些核心概念，这些概念必须在实际开始编写操作系统之前学习。任何超出“简单”范畴的示例都会阻碍概念的教授，因此会拉长写一个操作系统的准备时间。



接下来让我们开始学习吧。在本书中，我希望我能提供足够的基础知识，为你开启一扇理解其他资源的大门。这本书尤其适合那些刚学完 C/C++ 课程的学生。试想一下，到时候给未来雇主展示一下，哥哥我原来写过操作系统，这多牛逼啊。





### 预备知识



基本电路基础知识：

+ 电学的基础概念：原子，电子，质子，中子，电流
+ 欧姆定律



如果你不熟悉这些概念也没关系，我告诉你一个秘籍：

https://www.allaboutcircuits.com/textbook/ 只看前两章就行了



C 语言基础。尤其是：



+ 变量和函数声明/定义

+ `while` 和 `for` 循环 

+ 指针和函数指针 

+ C 中的基本算法和数据结构

  

Linux 基础：



+ 知道如何使用命令行打开目录
+ 知道如何使用选项调用命令 
+ 知道如何将输出管道传输到另一个程序



盲打的能力。由于我们使用的是 Linux 系统，因此盲打的能力会很有用。我知道打字速度并不能帮助你解决问题，但至少你的打字速度应该足够快，不要让它降低学习体验。

一般来说，我都假定读者具备基本的 C 语言编程知识，并且会使用 IDE 来构建和运行程序。



### 读完本书可以学到什么



+ 如何通过阅读硬件手册（hardware datasheets）从 0 开始写一个操作系统。在工程实践中，写操作系统的流程就是如此，你无法简单地通过 Google 获取答案。
+ 独立编写代码的能力。复制粘贴代码毫无意义。只有当你自己解决问题的时候，才是你学到东西的时候。书上会给出一些例子来启发你，但多数问题还是应该由你自己去克服。不要害怕，问题的答案还是会给你的，但仅供尝试后自我检验哟~
+ 从硬件到软件，全面了解计算机的层与层之间是如何关联的
+ 熟悉 Linux 的开发环境以及熟练使用通用的底层开发工具
+ 如何构建操作系统能够顺利运行的程序
+ 如何使用 gdb 和 QEMU 调试一个直接跑在硬件上的程序。
+ 用纯 C 链接和加载裸机 x86_64。没有标准库，也没有运行时开销。



### 本书啥没讲


（也有我暂时装不了的逼）



+ 电子工程

  本书讨论了电子学和电子工程的一些概念，但仅限于介绍软件在裸机上面跑的过程

+ 如何使用 Linux 或其他任何操作系统

  虽然 Linux 是本书的开发环境和演示高级操作系统概念的媒介，但它并不是本书的重点。

+ Linux 内核开发

  这方面已经有很多高质量书籍了

+ 专注于算法的操作系统书籍

  本书更侧重于实际的硬件平台（Intel x86_64），以及教你如何编写一个可以利用硬件平台相关支持的操作系统。



### 本书结构



**第 1 部分：讲解操作系统基础知识**



+ 第 1 章简述了相关文档的重要性。文档对于学习前人经验至关重要，因此它们值得独立成章  

+ 第 2 章解释了从硬件到软件的抽象层。我们的做法是深入理解代码在硬件上的实际运行过程

+ 第 3 章讲解了计算机的一般体系结构，然后介绍了用于编写操作系统的示例计算机模型

+ 第 4 章通过英特尔手册以及常用指令介绍了 x86 汇编语言。本章详细讲解了高级语法特性如何映射为低级汇编指令，使你能够轻松地阅读生成的汇编代码。在调试操作系统时，阅读汇编代码非常重要。

+ 第 5 章详细剖析了 ELF。只有在二进制码层面上理解了程序结构，你才能构建一个跑在裸机上的程序

+ 第 6 章介绍了 gdb 调试器，并给出了常用命令的大量示例。在熟悉了 gdb 以后，读者就能够深入理解调试器的工作原理。这些知识对于在裸机上构建可调试程序至关重要



**第 2 部分：介绍如何编写引导程序来启动内核，因此该部分名为“准备工作 ”。在掌握了这一部分之后，读者就可以继续下一部分的学习了，该部分则是编写操作系统的指南。但如果读者不喜欢这样的表述方式，也可以阅读其他材料，例如 [OSDev Wiki](http://wiki.osdev.org/)**



+ 第 7 章介绍了引导程序的定义，如何用汇编编写一个引导程序，以及如何在 QEMU（一个硬件模拟器）上加载它。此过程需要键入重复冗长的命令，因此要使用 GNU Make，通过自动化重复的部分和简化与项目的交互来提高生产力。本章还说明了 GNU Make 在上下文中的用法

+ 第 8 章通过解释组合目标文件时的重定位过程来介绍“链接”。除了引导程序和用 C 语言编写的操作系统之外，这是在裸机上构建可调试程序所需的最后一步。



**第 3 部分：提供了编写操作系统的指南。你需要自行实现操作系统，并为你的创造感到自豪。这份指南包括对实现操作系统特性所必须的概念更简单且明晰的解释，这些概念从硬件到软件，所涉广泛。没有这份指南，你就需要花费大量的时间，用于收集散布在网络和各类文档中的信息。这部分之后还会提供把概念转换为代码的指导**





### 致谢


感谢我亲爱的家人，感谢各位热心的贡献者。
