# 操作系统从 0 到 1



## 前言



哈喽！



你可能至少曾经问过自己一次如何从头开始编写操作系统。你可能已经有数年的编程经验了，然而，你对操作系统的理解可能仍然是一组抽象概念，而不是基于实际实现。对于那些从未造过操作系统的人来说，操作系统可能就是黑魔法：一个神秘的东西居然可以操控硬件还可以通过 API 处理程序员的请求。学习如何造一个操作系统，听起来十分吓人。感觉无论学了多少知识都不够。你可以立刻开始这本书的学习。为了成为更牛逼的软件工程师，让我们开始好好的理解操作系统吧。



**如果你就是我上面说的那类朋友，那么这本书就是为你打造的**。通过学习这本书，你将找到找到那些你错过的但是重要的知识。这些知识能够帮助你从零开始实现你自己的操作系统。真的，是从零开始。



你可能会问：学习 Linux 的系统内部不是更实际吗？



是的...但也不是



学习 Linux 可以帮助你的工作。但是，如果你按着那条路去走，你将不会实现写一个操作系统的最终目标。通过写一个你自己的操作系统，你将会获得你只学习 Linux 学不到的知识。



这是你学习操作系统的好处



+ 你将了解计算机如何在硬件级别工作，并且你将学习编写软件以直接管理该硬件
+ 你将学习操作系统的基础知识，使你能够适应任何操作系统，而不仅仅是 Linux
+ 要适当地破解 Linux 内部知识，你需要自己编写至少一个操作系统。这就像编写软件：想要搞波大的，就得先造个简单的
+ 你将开启各种底层编程的领域：逆向工程，虚拟机，游戏控制台模拟器等等。汇编将成为你底层分析最重要的工具（但不是意味着你要用汇编写个操作系统）
+ 写操作系统很好玩！



### 为啥要写这本书



有很多关于这个主题的书籍和课程。这些教程由知名专业人士和专家制作。我能写一本如此高级的书是不是在吹牛逼？虽然确实存在许多优质资源，但他们少了很多东西。

有任何一本书告诉你如何独立已存在的操作系统编译 C 代码和 C 运行库吗？大多数关于操作系统设计和实现的书籍只讨论软件方面，操作系统与硬件的交互被略过。重要的硬件细节被略过。而且自学者很难找到这方面的资源。

这本书的就是要消除这方面的代沟。你不仅仅会学习到如何直接在硬件上编程还会学习到如何阅读硬件供应商的官方文件来编程。你不再需要寻找资源来帮助自己解释硬件手册和文档：你自己就可以。

最后，我是以自学者的角度来写这本书的。我尽量写得想详细所以你可以花更少的时间学习。



这本书的焦点之一是教你通过阅读官方的文档实现自己的软件。这些来自像 Intel 的硬件产商的官方文档对直接跑在硬件上的操作系统或者软件是极其重要的。至少，一个操作系统开发者需要能够理解这些文档，在一系列硬件要求上完成软件。因此，第一章就是讨论相关文档以及其重要性。



另一个非常重要的特点是："Hello World" 中心。大多数例子围绕着 "Hello World" 编程。这让你了解这些核心概念。这些核心概念必须被学会。任何超过简单的 "Hello World" 的例子都会阻碍教授这些概念，因为这样会加长开始写一个操作系统的时间。



让我们和这本书一起潜下去。我希望我能提供足够的基础知识，帮助你理解这些资源。这本书尤其适合那些刚结束 C/C++ 课程的学生。想象一下，给以后的老板展示一下，哥哥我原来写过操作系统，是多么的牛逼啊。





### 小小的门槛



电路的基础知识：

+ 电学的基础概念：原子，电子，种子，质子，电流
+ 欧姆定律



如果你不熟悉也没关系，我告诉你一个秘籍：

https://www.allaboutcircuits.com/textbook/ 学习前两章就行了



C 语言基础尤其是：



+ 变量和函数声明/定义

+ while和for循环 

+ 指针和函数指针 

+ C中的基本算法和数据结构

  

Linux 基础：



+ 知道如何使用命令行打开目录
+ 知道如何使用选项调用命令 
+ 知道如何将输出管道传输到另一个程序



打字。我知道打字速度与解决问题无关，但至少你的打字速度应该足够快，不要让它降低学习体验。



读完这本书，你至少会学习到：



+ 如何通过阅读硬件数据表（hardware datasheets）从 0 写一个操作系统。在现实世界中，它就是这样的。你不能从 Google 中得到快速回答。
+ 从硬件到软件，全面了解计算机的层与层之间是如何关联的
+ 独立编写代码。复制粘贴代码毫无意义。当你自己解决问题的时候，才是你学到东西的时候。一些书上的例子会启发你，但是最大的问题还应该是你去克服。不要害怕，问题的答案还是会给你的，但这仅仅被用来在尝试后的自我检验
+ 熟悉 Linux 的开发环境以及熟悉使用常见的工具调试低级语言编程
+ 深入理解 x86 汇编
+ 一个程序到底是如何构造的以至于操作系统可以运行它
+ 如何使用 gdb 和 QEMU 调试一个直接跑在硬件上的程序。
+ 用纯 C 链接和加载裸机 x86_64。没有标准库。没有运行时开销。



## 这本书没讲啥



（也有我暂时装不了的逼）



+ 电子工程

  本书讨论了电子设备和电子工程的一些概念，这仅仅是为了介绍软件是如何跑在裸机上面的

+ 如何使用 Linux 或任何操作系统类型的书籍

  虽然 Linux 被用作开发环境和媒介来演示高级操作系统概念，但它并不是本书的重点。

+ Linux 内核开发

  这个主题上已经有很多高质量的书

+ 专注于算法的操作系统书籍

  本书更侧重于实际的硬件平台 - 英特尔 x86_64 - 以及如何编写一个利用硬件平台支持的操作系统。



### 这本书讲了啥



**第 1 部分为学习操作系统提供了基础。**



+ 第 1 章简要介绍了文档的重要性。文档对于学习体验至关重要，因此它们值得成为一个章节

  

+ 第 2 章解释了从硬件到软件的抽象层。我们的想法是深入了解代码的物理运行方式。

+ 第 3 章提供了计算机的一般体系结构，然后介绍了用于编写操作系统的示例计算机模型

+ 第 4 章通过使用英特尔手册以及常用指令介绍了 x86 汇编语言。本章详细介绍了高级语法如何与低级汇编程序相对应，使你能够轻松地阅读生成的汇编代码。在调试操作系统时，阅读汇编代码非常重要。

+ 第 5 章详细剖析了 ELF。只有通过了解二进制级别的程序结构，你才能在裸机上构建一个程序

+ 第 6 章介绍了 gdb debugger 以及常用命令的大量示例。你们熟悉了 gdb 以后，你就可以深入了解 debugger 的工作原理。这些知识对于在裸机上构建可调试程序至关重要



**第 2 部分介绍如何编写引导程序来引导内核。因此，被叫做 "Groundwork"。掌握了这一部分后，你们可以继续阅读下一部分，这是编写操作系统的指南。但是，如果你们不喜欢该演示文稿，可以查看其他地方，例如 [OSDev Wiki](http://wiki.osdev.org/)**



+ 第 7 章介绍了引导程序是什么，以及如何用汇编写一个，以及如何在 QEMU（一个硬件模拟器）上加载它。此过程涉及键入重复和长命令，因此可以用 GNU Make。通过自动化重复的部分和简化与项目的交互提高生产力。本章还说明了 GNU Make 在上下文中的用法
+ 第 8 章通过解释组合目标文件时的重定位过程来介绍链接。除了引导程序和用 c 语言编写的操作系统之外，这是在裸机上构建可调试程序所需的最后一块拼图。



**第 3 部分提供了有关如何编写操作系统的指南，此时你应该自己实现操作系统并为你的创建感到自豪。这份指南包括为了实现操作系统从硬件到软件必要概念的简单解释。没有这份指南，你将花费大量的时间收集信息。然后提供从概念到代码的蓝图**





