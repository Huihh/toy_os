# 第四章 X86的汇编语言和C语言




在这一章中，我们将探索汇编语言和它怎么跟C语言产生联系的。但是，我们为什么应该这样做呢？难道汇编语言更加相信编译器，而且没人在写汇编语言了。<br/><br/><br/>




不完全是这样。当然，目前编译器所在的艺术水平是值得信任的，而且我们大多数时间根本不需要使用汇编语言来编写代码。一个编译器能够产生代码，但是正如上文提到过的，一个高级语言是低级语言的集合体。编译器不能够遮蔽硬件平台提供的一切。因此，**编译器是不能够产生每一个汇编指令的**，所以面对这样的情况我们仍然需要编写汇编代码去访问硬件的某个确定的功能特性。因为我们需要写汇编代码去获取硬件的某个确定功能特性，调试的时候是需要阅读汇编代码。我们可能在阅读上花的时间比写还多。
<br/> 换一行





使用低级的代码直接与硬件交互，汇编代码是无法避免的。而且，理解一个编译器是怎样产生汇编代码的能够帮助一个程序员提高生产效率。比如，如果一个工作任务或者学校功课需要使用汇编代码完成，我们能够简单地使用C语言进行编写代码，然后使用 *gcc* 帮助我们编写汇编代码。我们仅仅是收集产生的汇编代码，按照我们的需要去修改它，以此来完成我们的任务。




我们将要扩展地学习*objdump* ,随着对objdump使用可以帮助我们理解x86的汇编代码。

![](https://upload-images.jianshu.io/upload_images/4377214-dd9ad68059da5405.png)




## 4.1 objdump




*objdump* 是一个展示对象文件信息的程序。它将很容易地调试错误。现在，我们使用*objdump* 来检查它是怎样把高级语言代码映射成汇编代码的。首先，我们将忽略输出然后学会使用这个指令。

事物就是这样，一开始我们总是屏蔽细节，随后才深入理解。
<br/><br/>



**$ objdump -d hello**




*-d* 选项表示   展示可执行片段的汇编内容。一个*片段* 是内存中的一个块，它包含了程序代码或者数据。一个代码片段是可被CPU执行的，然后一个数据片段是不能被执行的。非执行片段是不会展示的，比如*.data* 和 *.bss* （存储程序数据）、调试片段等。当我们在第5章109页学习*ELF* 二进制文件的时候会对片段有更多的了解。另一方面：



**$ objdum -D hello**



-D 选项表示   展示所有片段的汇编内容。 因为 *objdump* 常被使用检查汇编代码，而 *-d* 是非常有用的，因此 *-d* 是默认设置。

<br/><br/>




输出超出了终端屏幕。为了可读性，给输出加上 *less*:（直接在终端展示反汇编后的内容信息）

**$ objdump -d hello | less**

<br/><br/>


为了混合源代码和汇编代码，这个二进制必须使用 *-g* 选项以此包含源代码，然后加上 *-S* 选项：（objdump --help 可以看见每一个选项的详细说明）

**$ objdump -S hello | less**

<br/><br/>


*objdump* 使用默认的**AT&T**的风格。可以修改为熟悉的**Intel**风格：

**$ objdump -M intel -D hello | less**




当使用 *-M* 选项的时，选项 *-D* 或者 *-d* 一定要显示使用。下一步，我们将要使用 *objdump*来检查被编译的C语言代码在机器中是怎样的一种表现形式。

<br/><br/>


最后，我们将要写一个32位的内核，因此需要编译一个32位的二级制和使用32位的模式来检查它：

**$ objdump -M i386,intel -D hello | less**




*-M i386*  告诉 *objdump* 使用32位风格展示汇编代码内容。**对于编写内核代码，了解32位和64位的差异是非常重要的。**随后我们写内核代码的时候会检查这个差异。
<br/><br/><br/>




## 4.2 阅读输出的内容



这个对象文件的文件风格的最开始显示如下：



**hello: file format elf64-x86-64**



随后的行就是一些列反汇编的片段：

**Disassembly of section .interp:**<br/>
**...**<br/>
**Disassembly of section .note.ABI-tag:**<br/>
**...**<br/>
**Disassembly of section .note.gnu.build-id:**<br/>
**...**<br/>
**...**<br/>



等等。<br/>

最后，每一个反汇编片段显示了真实的内容是一个有顺序的汇编指令，使用如下格式：

&emsp;&emsp;**4004d6:      &emsp;&emsp;&emsp;&emsp;   55   &emsp;&emsp;&emsp;&emsp;&emsp;              push    rbp**



+ **第一列**是汇编指令的地址。在上面的例子中，它的地址就是**0x4004d6**。

+ **第二列**是原始十六进制值中的汇编指令。在上面的例子中，它的地址就是**0x55**。

+ **第三列**是一个汇编指令。这个指令片段说明汇编指令是否有意义。比如，如果这个汇编指令是在一个 *.text* 片段中，则它是确切的程序代码。另一方面，如果这个汇编指令显示是在 *.data* 片段中，然后我们可以安全地忽略这个指令。原因就是 *objdump* 不知道哪个16进制值是代码还是数据，所以 *objdump* 会盲目地翻译每一个16进制到汇编指令中。在上面的例子中，这个汇编指令是 *push %rbp*。
+ 第四列是一个注释，可选项。当是一个引用地址的时候，可以显示。可以告诉我们这个地址的原始位置。如下<font color="#000066">蓝色</font>的就是注释：


lea r12,<font color="#660000">[rip+0x2008ee]</font><font color="#000066"># 600e10 <__frame_dummy_init_array_entry></font>

它的目的就是通知从<font color="#660000">[rip+0x2008ee]</font>中获得引用地址是font color="#000066">0x600e10</font>，在这个 **__frame_dummy_init_array_entry** 变量中。




在反汇编片段中，它可能包含*标签*。一个标签就是一个汇编指令的名称。这个标签指示了一个可供人类读者容易理解的汇编代码块。比如，*.text* 片段包含的标签就可以指示代码在程序的开始处。*.text* 片段下面部分有两个函数<font color="#660000">_start</font> 和 <font color="#660000">deregister_tm_clones</font>。这个<font color="#660000">_start</font>函数开始的地址是<font color="#000066">4003e0</font>，这个地址在函数名称的左边被注释。<font color="#660000">_start</font>标签右边仍然是在地址<font color="#000066">4003e0</font>中的一个指令。这些所有的事情都意味着一个标签仅仅是一个存储地址的名称。**deregister_tm_clones** 同样是如上的风格。
![](https://upload-images.jianshu.io/upload_images/4377214-f20393d51021d5f3.png)





## 4.3 Intel 风格的操作手册




（了解一下 Intel 和 AT&T 的汇编风格）

为了更好地理解和使用汇编语言，我们需要精确地理解计算机架构体系和每一个机器指令做了什么。最好的资源文档就是来自供应商提供的。毕竟，硬件供应商是制作机器的。为了更好理解Intel风格的指令集，我们需要文档 *Intel 64 and IA-32 architectures software developer’s
manual combined volumes 2A, 2B, 2C, and 2D: Instruction set reference,
A-Z*。获取地址：[Intel manual]( https://software.intel.com/en-us/articles/intel-sdm)


<br/>

+ 第一章提供了简短的信息和如何使用这本书。
+ 第二章对汇编指令进行了深度剖析。
+ 第三到五章提供了关于x86_64架构体系的每个指令细节。
+ 第六章提供了关于安全模式的扩展。我们将不需要使用这章。



<br/>

第一册 *Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 1: Basic Architecture* 描述了基于 *Intel* 处理器的基本架构体系和编程环境。第5章对所有的 *Intel*指令集进行了分类整理和总结。我们学习开发的*OS* 只需要学习 *5.1章*。第七章描述了每个分类的目的。随后，我们将要学习所有这些指令。

**练习 4.3.1.** 阅读第二册的1.3部分，排除1.3.5和1.3.7。



<br/><br/>

## 4.4 使用汇编代码试验



